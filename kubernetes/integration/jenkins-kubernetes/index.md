---
metaTitle: Интеграция CI/CD с Jenkins и Kubernetes
metaDescription: Узнайте, как интегрировать Jenkins и Kubernetes для современных CI/CD процессов — лучшие практики, примеры, автоматизация развертывания приложений и масштабирования пайплайнов
author: Олег Марков
title: Интеграция CI/CD с Jenkins и Kubernetes
preview: Разберитесь, как интегрировать Jenkins и Kubernetes для автоматизации CI/CD — пошаговые примеры, инструкции по настройке пайплайнов, секретов и масштабирования
---

## Введение

Интеграция Jenkins и Kubernetes — распространенное решение для построения отказоустойчивых и масштабируемых CI/CD пайплайнов. Если вы разрабатываете приложения и хотите внедрить автоматическую доставку, развертывание и тестирование в облачной среде, такой подход открывает новые горизонты по скорости, надежности и гибкости.

Jenkins — один из самых популярных open source инструментов для автоматизации сборки, тестирования и доставки. Но если запускать Jenkins на виртуальных машинах, появляется проблема масштабирования и управления ресурсами. Здесь на сцену выходит Kubernetes — система оркестрации контейнеров, умеющая легко запускать контейнеры, распределять нагрузку и автоматически масштабировать нагрузку по мере необходимости.

В этой статье вы узнаете:

- Как устроена интеграция Jenkins и Kubernetes
- Как настраивать масштабируемые среды для сборки и тестирования
- Как писать пайплайны, которые быстро и надежно работают в облачной инфраструктуре
- Как хранить секреты и обеспечивать безопасность пайплайнов
- Какие плагины Jenkins использовать и как с ними работать
- Какие ошибки чаще всего возникают и как их быстро решить

Пошаговые инструкции, примеры кода и разъяснения помогут вам легко внедрить и использовать такой стек на практике.

---

## Обзор архитектуры CI/CD с Jenkins и Kubernetes

Интеграция начинается с выбора архитектурного подхода. Посмотрим, как обычно выглядит связка Jenkins и Kubernetes на практике:

- Jenkins Master развернут внутри Kubernetes или снаружи кластера и управляет пайплайнами.
- Для каждого задания Jenkins может динамически запускать отдельные build-агенты в виде подов Kubernetes.
- Все параметры (сборка, тесты, деплой, переменные) задаются в файле Jenkinsfile.
- Kubernetes обеспечивает масштабирование рабочих агентов и изоляцию процессов.
- Секреты, переменные окружения, конфиги хранятся в Kubernetes Secrets и ConfigMaps для безопасности.

Схематично этот процесс выглядит вот так:

1. Разработчик коммитит код на GitHub/GitLab/Bitbucket.
2. Jenkins получает событие (webhook) и запускает пайплайн.
3. Jenkins-мастер создает новый под build-агента через Kubernetes API.
4. Выполняется пайплайн: сборка, тесты, деплой.
5. Агент автоматически удаляется после завершения задания.

Такое решение удобно для команд разного размера и любого объема задач по автоматизации.

---

## Установка Jenkins в Kubernetes

Теперь перейдем к практике. Один из самых удобных способов развернуть Jenkins в Kubernetes — использовать Helm Charts.

### Разворачивание Jenkins с помощью Helm

Helm — это пакетный менеджер для Kubernetes, который умеет "ставить" приложения одной командой.

Вот пример запуска Jenkins через Helm:

```bash
# Добавьте репозиторий Helm charts для Jenkins
helm repo add jenkins https://charts.jenkins.io
helm repo update

# Установите Jenkins с базовой конфигурацией
helm install my-jenkins jenkins/jenkins
```
Этот пример создаст все необходимые ресурсы: Deployment, Service, PVC для данных, необходимые секреты и сетевое взаимодействие.

Вы сможете получить пароль для доступа к UI Jenkins так:

```bash
kubectl get secret --namespace default my-jenkins -o jsonpath="{.data.jenkins-admin-password}" | base64 --decode
```

Теперь вы можете зайти в браузере по адресу NodePort или через Ingress (если настроен) — обычно это:

```
http://<NODE_IP>:<NODE_PORT>
```

#### Настройка хранилища

Для сохранения данных между рестартами создается PersistentVolumeClaim. Helm chart позволяет задать параметры типа:

```yaml
persistence:
  enabled: true
  size: 8Gi
```
Эта настройка пригодится, если надо сохранить историю билдов, настроек и плагинов.

---

## Настройка Jenkins и интеграция с Kubernetes

Чтобы Jenkins мог создавать и управлять агентами через Kubernetes, потребуется плагин Kubernetes.

### Установка и настройка Kubernetes Plugin

1. Перейдите в Jenkins UI: Manage Jenkins → Manage Plugins.
2. Установите Kubernetes plugin (и по желанию CloudBees Kubernetes CI).
3. После перезапуска сервера — снова зайдите в Manage Jenkins → Configure System.

Заполните параметры подключения к кластеру Kubernetes:

- **Kubernetes URL** — можно оставить пустым (Jenkins сам определит адрес по serviceAccount, если работает внутри кластера)
- **Kubernetes Namespace** — пространство имен, где будут создаваться агенты. Обычно совпадает с пространством Jenkins, но можно указать отдельное.
- **Jenkins URL** — внутренний адрес доступа агентов к мастеру (например, http://my-jenkins:8080)
- **Pod Template** — шаблоны подов для build-агентов. Вы можете задать контейнеры (например, с docker, git, maven, node и т.д.)

### Пример Pod Template в настройках

```yaml
- name: "jnlp"
  image: "jenkins/inbound-agent:latest"
  args: []
  env:
    - name: JAVA_OPTS
      value: "-Xmx512m"
```
Вся инструкция задается через UI Jenkins, но можете делать это и через values.yaml вашего Helm chart, если предпочитаете хранить конфигурацию в GitOps стиле.

---

## Пример пайплайна с использованием Kubernetes-агентов

Посмотрите, как работает типичный Jenkinsfile, если вы используете Kubernetes-агента.

```groovy
pipeline {
  agent {
    kubernetes {
      yaml """
apiVersion: v1
kind: Pod
spec:
  containers:
    - name: maven
      image: maven:3.8.5-openjdk-11
      command:
        - cat
      tty: true
    - name: docker
      image: docker:20-dind
      securityContext:
        privileged: true
      ports:
        - containerPort: 2376
"""
      defaultContainer 'maven'
    }
  }
  stages {
    stage('Build') {
      steps {
        container('maven') {
          sh 'mvn clean package' // Сборка Java-приложения
        }
      }
    }
    stage('Test') {
      steps {
        container('maven') {
          sh 'mvn test'
        }
      }
    }
    stage('Docker Build') {
      steps {
        container('docker') {
          sh 'docker build -t myapp:${BUILD_NUMBER} .' // Сборка Docker-образа
        }
      }
    }
    stage('Push Image') {
      steps {
        container('docker') {
          withCredentials([usernamePassword(credentialsId: 'docker-registry', usernameVariable: 'DOCKER_USER', passwordVariable: 'DOCKER_PASS')]) {
            sh 'echo $DOCKER_PASS | docker login -u $DOCKER_USER --password-stdin registry.mydomain.com'
            sh 'docker push registry.mydomain.com/myapp:${BUILD_NUMBER}'
          }
        }
      }
    }
  }
}
```

- Обратите внимание, что для каждого шага пайплайна мы выбираем контейнер (через `container('maven')` или `container('docker')`), которые указаны в поде Kubernetes.
- Все переменные и секреты можно хранить используя Jenkins Credentials.
- После окончания работы под-агент автоматически удаляется Kubernetes — это экономит ресурсы кластера.

---

## Работа с секретами и переменными окружения

Для CI/CD жизненно важно хранить пароли, токены и другие чувствительные данные в секрете.

### Секреты в Jenkins

Jenkins поддерживает собственный сторедж Credentials. Например, вы добавляете логин/пароль Docker Registry, и используете их в пайплайне через блок `withCredentials`.

### Kubernetes Secrets

Если вся команда уже перешла на Kubernetes и нужно управлять секретами централизованно, разумно использовать Kubernetes Secrets:

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: docker-secret
type: kubernetes.io/basic-auth
stringData:
  username: myuser
  password: mypass
```

В под-агентах можете смонтировать секреты напрямую через volume:

```yaml
volumes:
  - name: docker-secret
    secret:
      secretName: docker-secret
```

Или использовать переменные окружения — пример для Java:

```yaml
env:
  - name: DOCKER_USER
    valueFrom:
      secretKeyRef:
        name: docker-secret
        key: username
  - name: DOCKER_PASS
    valueFrom:
      secretKeyRef:
        name: docker-secret
        key: password
```

---

## Масштабирование, отказоустойчивость и безопасность

### Автоматическое масштабирование агентов

Kubernetes сам масштабирует Jenkins агенты в зависимости от количества задач. Вам нужно только выставить лимиты по CPU и памяти в шаблоне пода — Kubernetes распределит ресурсы и не даст создать слишком много агентов (что полезно для контроля расходов и стабильности).

### Настройка ролей и политик

Чтобы повысить безопасность, на уровне Kubernetes рекомендуется:

- Обрезать права ServiceAccount, через который Jenkins создает поды (использовать RBAC).
- Использовать Network Policies для ограничения доступа между подами.
- Применять PodSecurityPolicies (если требуется ограничить права запуска контейнеров).

Не делайте Jenkins-мастер root-пользователем и старайтесь не давать агентам лишних привилегий.

### Логирование и мониторинг

Желательно настроить аналитику логов и метрик Jenkins и агентов:

- Используйте Prometheus и Grafana для мониторинга ресурсов.
- Логи подов можно агрегировать в Elasticsearch/Fluentd/Kibana (EFK) стек.

---

## Типичные ошибки и способы их решения

1. **Jenkins агенты не запускаются**  
   - Проверьте RBAC политики для сервиса Jenkins.
   - Убедитесь, что правильно указали Namespace и адрес Jenkins Master в настройках плагина.
2. **Проблемы с памятью или CPU**  
   - Задайте resource requests и limits для подов агентов.
   - Увеличьте лимиты, если пайплайн прерывается по OOM.
3. **Проблемы со сборкой Docker-образов**  
   - Проверьте, что агент запускается с нужным образом docker-in-docker (dind).
   - Разрешите привилегированный режим для контейнера.
4. **Проблемы со входом в Registry**  
   - Убедитесь, что добавили секреты для авторизации в Docker Registry.
   - Проверьте переменные окружения и их соответствие ключам.

---

## Практичные рекомендации и полезные плагины

### Какие плагины стоит рассмотреть:

- Kubernetes Plugin — для автоматического запуска агентов
- GitHub/GitLab Integration — для webhooks и CI
- Blue Ocean — визуальный UI для пайплайнов, помогает начинающим быстро разобраться
- Credentials Binding Plugin — удобная работа с логинами и паролями
- Docker Pipeline Plugin — удобно писать пайплайны, которые собирают контейнеры

### Советы по оптимизации пайплайнов

- Разбивайте крупные пайплайны на независимые стейджи и переиспользуйте кэш (Docker Layer Cache или Maven/.npm кэш)
- Используйте агентские шаблоны с нужными инструментами, чтобы не тащить все в один образ агентов
- Работайте с секретами только через специальные плагины или integration points, чтобы не хранить их в открытом виде

---

## Заключение

Jenkins в связке с Kubernetes сегодня — универсальное и мощное решение для построения современных CI/CD пайплайнов. Вы получаете максимальную гибкость в настройке агентов, масштабировании ресурсов и безопасности среды. Благодаря Kubernetes, каждый билд или тест изолирован, нагрузка легко масштабируется, а Jenkins открывается новым возможностям благодаря Docker и облачной архитектуре.

Сочетая автоматизацию, простоту запуска новых сборок и современную работу с секретами, вы можете быстро выстроить конвейер, который надежно и предсказуемо доводит код от коммита до продакшена.

---

## Частозадаваемые технические вопросы по теме статьи и ответы на них

### Как обновлять плагины Jenkins в Kubernetes без потерь данных?

**Ответ:**  
Обновляйте плагины через Jenkins UI, затем перезапустите pod Jenkins через команду `kubectl rollout restart deployment <jenkins-deployment>`. Для сохранности настроек убедитесь, что `persistence.enabled` в values.yaml Helm chart включен, а PVC подмонтирован к каталогу `/var/jenkins_home`.

### Как добавить кастомные образы для build-агентов?

**Ответ:**  
В настройках Kubernetes Plugin добавьте новый pod template с вашим Docker-образом. Укажите публичный или приватный registry, и если нужно — настройте секреты доступа через Docker Registry Secrets Kubernetes.

### Как реализовать shared library пайплайны с вызовом общих функций?

**Ответ:**  
Создайте репозиторий с общими groovy-скриптами и подключайте его в Jenkins через настройку Global Pipeline Libraries. В Jenkinsfile используйте `@Library('my-shared-library') _` и вызывайте ваши функции как обычные groovy-методы.

### Как разрешить сборки под Windows- или ARM-агентами в Kubernetes?

**Ответ:**  
Создайте node-pool или Worker Placement в кластере под нужную архитектуру (Windows, ARM). В pod template укажите nodeSelector для соответствующего типа узлов, чтобы Kubernetes запускал поды на целевых нодах.

### Как ограничить количество одновременно работающих билд-агентов?

**Ответ:**  
В настройках Kubernetes Cloud в Jenkins задайте максимальное количество одновременно работающих подов (`Maximum number of agents`). Kubernetes сам обеспечит, что ресурсный лимит не будет превышен. Если хотите гибкости — используйте лимиты на side количества подов в Helm chart Jenkins или через Quota в Kubernetes.