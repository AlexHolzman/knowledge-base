---
metaTitle: Как настроить CD в Kubernetes
metaDescription: Подробная инструкция по настройке CD в Kubernetes - принципы, примеры пайплайнов, выбор инструментов и автоматизация доставки приложений
author: Олег Марков
title: Как настроить CD в Kubernetes
preview: Разбираемся, как организовать процесс непрерывной доставки CD в Kubernetes, настраиваем пайплайны и автоматизируем деплоймент с помощью популярных инструментов
---

## Введение

Kubernetes стал стандартом для развертывания и управления приложениями в облачной инфраструктуре благодаря своей гибкости и возможностям масштабирования. Однако только развернуть приложение в Kubernetes недостаточно – гораздо важнее обеспечить эффективную, быструю и безопасную доставку нового кода в рабочие окружения. Здесь на помощь приходит концепция Continuous Delivery (CD) – непрерывной доставки.

CD позволяет вам сразу после прохождения всего жизненного цикла разработки быстро и автоматически переносить успешно собранные и протестированные изменения в production или staging среды. Благодаря этому вы ускоряете время выхода новых функций, снижаете количество ошибок из-за человеческого фактора и добиваетесь более качественного цикла разработки. В этой статье я покажу, как вы можете реализовать и настроить полноценный CI/CD пайплайн для Kubernetes. Мы разберем, какие инструменты использовать, как построить процесс деплоймента, что нужно настроить для автоматизации и какие best practices помогут вам избежать типичных ошибок.

## Основные компоненты CD в Kubernetes

Чтобы вам было проще ориентироваться в обилии информации, давайте сразу определим ключевые этапы настройки CD в кластере Kubernetes:

- Выбор инструмента CD (например, GitLab CI, Jenkins, Argo CD, FluxCD и др.)
- Сборка Docker образов и публикация в реестр
- Обновление манифестов Kubernetes
- Деплоймент в целевое окружение с автоматизацией процесса
- Мониторинг и откаты (rollback)

Давайте рассмотрим подробно каждый шаг на понятных примерах.

### Выбор инструмента для CD в Kubernetes

На рынке есть несколько популярных решений для построения CD процессов для Kubernetes. Вот короткое сравнение по самым востребованным:

- **Jenkins** — популярный open source инструмент, хорошо интегрируется с Kubernetes через Jenkins X и плагины, масштабируется горизонтально.
- **GitLab CI/CD** — встроен в GitLab, поддерживает работающие пайплайны, управляется через `.gitlab-ci.yml`, прост в использовании для репозиториев GitLab.
- **Argo CD** — современный инструмент CD, основанный на GitOps подходе, отлично подходит для декларативного управления Kubernetes приложениями через Git.
- **FluxCD** — еще одна реализация GitOps, хорошо масштабируется, интегрируется с Helm.

Каждое из решений можно выбрать исходя из особенностей вашей команды, инфраструктуры и уже используемых инструментов.

Для примера ниже я сосредоточусь на GitLab CI/CD и Argo CD — двух наиболее популярных решениях для Kubernetes.

---

### Реализация CD пайплайна на GitLab CI/CD

GitLab CI/CD позволяет описывать весь процесс поставки через файл `.gitlab-ci.yml` в корне вашего репозитория.

#### Пример пайплайна для CD

Давайте рассмотрим типовой пример пайплайна для Kubernetes:

```yaml
stages:
  - build
  - push
  - deploy

variables:
  DOCKER_IMAGE: registry.example.com/myservice:$CI_COMMIT_SHORT_SHA

build:
  stage: build
  script:
    # Построение Docker-образа
    - docker build -t $DOCKER_IMAGE .
  only:
    - main

push:
  stage: push
  script:
    # Логинимся в реестр и пушим образ
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
    - docker push $DOCKER_IMAGE
  only:
    - main

deploy:
  stage: deploy
  image: lachlanevenson/k8s-kubectl:latest
  script:
    # Обновляем deployment с новым образом
    - kubectl set image deployment/myservice myservice=$DOCKER_IMAGE --namespace=production
  only:
    - main
```

**Объясню, как работает этот пайплайн:**

- На этапе `build` вы собираете новый Docker-образ вашего приложения.
- На этапе `push` пушите этот образ в приватный или публичный Docker Registry.
- На этапе `deploy` происходит обновление соответствующего Deployment в Kubernetes на новый образ.

**Обратите внимание**: Для подключения к вашему Kubernetes кластеру GitLab Runner должен быть правильно настроен – нужны переменные окружения с kubeconfig и токенами доступа.

#### Как устроить безопасный деплой

Настройте отдельные окружения (staging, production) и переменные в GitLab для разных кластеров. Пример для staging:

```yaml
deploy_staging:
  stage: deploy
  environment:
    name: staging
  script:
    - kubectl set image deployment/myservice myservice=$DOCKER_IMAGE --namespace=staging
  only:
    - staging
```

Это позволит деплоить конкретные ветки на нужные окружения, а запускать обновления на production – только после ручной валидации.

---

### Декларативное CD с помощью Argo CD (GitOps)

Если вам больше подходит декларативный подход, рекомендую рассмотреть Argo CD. В нем вы управляете желаемым состоянием кластеров через Git-репозиторий с описанием манифестов.

#### Установка Argo CD в Kubernetes

Покажу, как быстро развернуть Argo CD в вашем кластере:

```bash
kubectl create namespace argocd
kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
```

**Комментарий:**  
- Здесь мы создаём неймспейс `argocd` и применяем официальный манифест установки.

#### Первичное подключение к Argo CD UI

После установки получите пароль для пользователя `admin`:

```bash
kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d
```

Далее запускаете UI через порт-форвардинг:

```bash
kubectl port-forward svc/argocd-server -n argocd 8080:443
# После этого UI будет доступен на https://localhost:8080
```

#### Описание приложения для Argo CD

Создайте в Git репозитории папку с Kubernetes манифестами вашего приложения. Затем опишите приложение в Argo CD через CRD:

```yaml
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: my-app
  namespace: argocd
spec:
  project: default
  source:
    repoURL: 'https://gitlab.com/yourorg/yourrepo.git'
    targetRevision: HEAD
    path: k8s-manifests/my-app
  destination:
    server: 'https://kubernetes.default.svc'
    namespace: production
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
```

**Что здесь происходит:**
- В секции `source` указываем адрес репозитория и путь с манифестами.
- В `destination` — кластер и неймспейс, куда деплоить.
- Политика `syncPolicy` позволяет автообновление (autodeploy) и самовосстановление (self-heal).

Теперь любые коммиты с изменениями манифестов через Git автоматически приводят ваш production к ожидаемому состоянию.

#### Динамическая замена тегов Docker-образов

Рекомендую использовать шаблонизаторы, например, `Kustomize` или Helm — это позволит варьировать версии образов при автоматизации CD.

**Пример с Kustomize:**

```yaml
# kustomization.yaml
images:
  - name: myservice
    newTag: v1.2.3
```
**Комментарий:**  
- Вы указываете, какой тег применять для текущего деплоя — это делается CI/CD системой перед пушем в Git.

**Как это происходит на практике:**
- В CI пайплайне после публикации нового образа происходит автозамена тега/sha в манифестах, затем коммит и пуш изменений в репозиторий с манифестами. Argo CD увидит обновление и автоматически задеплоит новую версию.

---

### Проверка деплоев и откаты (rollback)

Правильно настроенный CD-процесс обязательно должен включать мониторинг, проверку состояния и возможность быстро откатить изменения.

#### Проверка статуса деплоя

Kubernetes по умолчанию работает с обновлениями через стратегии rollout. Вы можете следить за процессами через команду:

```bash
kubectl rollout status deployment/myservice
```
**Комментарий:**  
- Эта команда показывает, применён ли новый образ корректно и успешен ли деплой.

#### Откат к предыдущей версии

Для быстрого отката (на случай ошибки) используйте:

```bash
kubectl rollout undo deployment/myservice
```
**Комментарий:**  
- После выполнения команда избавит вас от проблемной версии, вернув рабочую.

Argo CD также поддерживает функцию автопересинхронизации, откатов и ручного управления версиями прямо из web-интерфейса.

---

### Лучшие практики для CD в Kubernetes

**1. Храните все инфраструктурные и приложения манифесты в Git**  
Используйте Git как единственный источник правды (Single Source of Truth).

**2. Разграничивайте окружения**  
Создавайте отдельные папки/библиотеки для staging, production. Используйте разные кластеры или namespace.

**3. Используйте шаблонизацию манифестов**  
Используйте Helm, Kustomize или менеджеры переменных, чтобы избежать дублирования деклараций для разных сред.

**4. Разделяйте CD для инфраструктуры и приложений**  
Обновления системных компонентов и бизнес-приложений стоит оформлять разными пайплайнами и репозиториями.

**5. Настройте уведомления и мониторинг**  
Интегрируйте алерты с Slack, Teams, почтой или дашбордами для быстрого реагирования на неудачные деплои.

**6. Управляйте доступами к кластеру**  
Ограничьте права сервис-аккаунтов, используемых CI/CD пайплайнами, только нужными namespace и действиями.

**7. Запускайте smoke-тесты после деплоя**  
Обеспечьте автоматическую проверку приложения сразу после обновления.

---

## Заключение

CD (Continuous Delivery) в Kubernetes позволяет вам автоматизировать и ускорить попадание нового кода на реальные серверы, снижая ручной труд и вероятность ошибок. Использование инструментов вроде GitLab, Argo CD или Jenkins даёт вам гибкость, а сочетание CI, шаблонизаторов и GitOps — прозрачность и безопасность. Как видите на примерах, процесс настройки достаточно прост, если разбить его на этапы: сборка образа, пуш в реестр, обновление манифестов, применение кластере. Добавив принципы best practices, вы получите работающую, надёжную систему доставки изменений.

---

## Частозадаваемые технические вопросы по теме статьи и ответы на них

### Как хранить и защищать секреты (например, токены и пароли) при CD в Kubernetes?

Для хранения секретов используйте ресурсы Kubernetes Secret, шифруйте их через сторонние решения (например, Sealed Secrets или HashiCorp Vault) и никогда не размещайте секреты в явном виде в Git.  
Мини-инструкция:  
- Создайте секрет:  
  ```
  kubectl create secret generic my-secret --from-literal=password=YOUR_PASSWORD --namespace=my-ns
  ```
- Шифруйте манифесты:  
  ```
  kubeseal <my-secret.yaml> -o yaml > sealed-secret.yaml
  ```
- Используйте sealed-secret.yaml в Git.

### Как настроить автоматическую проверку приложения после деплоя?

Добавьте в ваш CI/CD пайплайн отдельный этап, запускающий Smoke или end2end тесты против только что обновлённого сервиса.  
Пример (в GitLab CI):  
```yaml
test:
  stage: test
  script:
    - curl -f http://myapp/healthz
```

### Как откатить Argo CD приложение к предыдущей версии?

Через UI выберите нужную ревизию в разделе History и нажмите "Rollback". Через CLI:
```
argocd app rollback <app-name> <revision>
```

### Как деплоить сразу несколько микросервисов с независимыми манифестами?

Рекомендуется создать несколько папок/репозиториев для манифестов каждого сервиса либо использовать Helm charts с зависимостями. В Argo CD удобно создать отдельное `Application` для каждого сервиса.

### Как обновлять только deployment, не трогая сервисы и ingress?

Указывайте в `kubectl apply` путь только к deployment манифесту, либо связывайте пайплайн только с нужным ресурсом. В Argo CD можно разделить манифесты по путям и назначить для разных Application разный набор ресурсов.