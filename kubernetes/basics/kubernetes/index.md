---
metaTitle: Kubernetes что это и как работает
metaDescription: Простое объяснение Kubernetes - что это такое, как он работает и зачем нужен для управления контейнерами в современных приложениях
author: Олег Марков
title: Kubernetes что это и как работает
preview: Узнайте что такое Kubernetes, зачем он нужен и как его использовать для эффективного управления контейнерами - понятное объяснение, инструкции и примеры
---

## Введение

Kubernetes часто называют "операционной системой" для контейнеризированных приложений. Если вам приходилось запускать приложения в Docker-контейнерах, вы наверняка сталкивались с необходимостью масштабировать их, обновлять без прерывания сервиса, балансировать нагрузку, автоматически восстанавливать при сбоях. Одно контейнерное приложение запустить просто, но что делать, когда инфраструктура разрастается до десятков и сотен контейнеров? Именно для решения этих задач был создан Kubernetes.

Kubernetes (или "k8s") - это открытая платформа для автоматизации развертывания, масштабирования и управления контейнеризированными приложениями. Она помогает разработчикам и системным администраторам избавиться от рутины, связанной с ручным управлением контейнерами, и дает удобные инструменты для организации сложной облачной инфраструктуры.

Давайте подробно разберем, из чего состоит Kubernetes, как он работает, а также рассмотрим основные концепции, архитектуру и практические примеры запуска приложений.

## Архитектура Kubernetes

### Основные компоненты

Kubernetes устроен по принципу клиент-серверной архитектуры — центральная часть (Kubernetes Control Plane) управляет рабочими узлами (Nodes), на которых запускаются ваши контейнеры.

**Краткое описание ключевых компонентов:**

- **Control Plane** (Плоскость управления) — мозг Kubernetes-кластера. Состоит из набора компонентов, определяющих, какие приложения и где должны работать.
- **Nodes** (Узлы) — физические или виртуальные серверы, где фактически исполняются ваши контейнеры.
- **Pod** — минимальная, неделимая единица развертывания в Kubernetes. В каждом Pod может быть один или несколько контейнеров, которые делят между собой хранилище, сеть и некоторые настройки.

#### Распределение ролей

Обратите внимание, как происходит взаимодействие компонентов:

- Вы создаете описание приложения и желаемого состояния в формате YAML/JSON.
- Контроллеры на стороне Control Plane следят за состоянием кластера — они должны привести его к заданному описанию.
- Рабочие узлы исполняют контейнеры, разворачивают Pods, передают информацию о состоянии в Control Plane.

### Детальный разбор компонентов Control Plane

#### API Server

Это центральная точка входа в кластер. Все команды, изменения и обращения к Kubernetes проходят через API Server.

```bash
# Пример обращения к API Server через команду kubectl
kubectl get pods
```

#### Scheduler

Решает, на какой Node разместить новый Pod с учетом загрузки, ограничений по ресурсам, политик.

#### Controller Manager

Следит за текущим состоянием и запускает контроллеры — процессы, которые выполняют различные задачи: создание реплик, обработка сбоев, автомасштабирование.

#### Etcd

Это распределенное хранилище ключ-значение, где Kubernetes сохраняет все данные о своем состоянии (например, текущие настройки, состояние кластера, имена Pods и т.д.).

#### Kubelet

Агент на каждом узле. Следит за тем, чтобы контейнеры, которые должны быть запущены на этом узле, действительно работали.

#### Kube Proxy

Отвечает за сетевое взаимодействие: реализует правила маршрутизации, обеспечивает доступ к сервисам снаружи и внутри кластера.

## Основные объекты и концепции Kubernetes

### Pods

Pod — это наименьшая "единица развертывания" в Kubernetes. Обычно в Pod находится один контейнер, но иногда встречаются и "multi-container Pods" (например, дополнительные sidecar-контейнеры для логирования или проксирования).

**Пример YAML-файла для Pod:**

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: my-pod
spec:
  containers:
    - name: my-container
      image: nginx:1.25
# Этот Pod развернет один контейнер NGINX версии 1.25
```

### ReplicaSets и Deployments

Когда вам нужно не один экземпляр приложения, а несколько (например, для устойчивости к сбоям), используются ReplicaSet и Deployment.

- **ReplicaSet** следит за числом идентичных Pod-ов.
- **Deployment** управляет процессом обновления, отката, масштабирования ReplicaSet.

**Пример Deployment, который содержит 3 реплики nginx:**

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  replicas: 3 # Количество подов
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.25
```

Такое описание Deployment автоматически создаст и будет поддерживать три одновременных работающих Pod с NGINX.

### Сервисы (Services)

Pod-ы динамически создаются и удаляются, их IP-адреса не постоянны. Чтобы организовать стабильный доступ, в Kubernetes используются сервисы.

**Service** — объект, который обеспечивает постоянный IP-адрес и DNS-имя для группы Pod-ов.

**Пример сервиса для доступа к нашим Pod-ам:**

```yaml
apiVersion: v1
kind: Service
metadata:
  name: nginx-service
spec:
  selector:
    app: nginx # Указывает, к каким Pod обращаться
  ports:
    - protocol: TCP
      port: 80
      targetPort: 80
  type: ClusterIP # Сервис доступен только внутри кластера
```

### Namespaces

Namespaces позволяют разделять ресурсы кластера между разными командами, проектами или средами (dev, staging, production). Это очень удобно для командной работы или изоляции.

**Пример создания Namespace:**

```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: dev-environment
```

Теперь вы можете создавать объекты (Pod, Service) внутри этого Namespace.

### Volumes и Storage

По умолчанию данные в контейнере не сохраняются между перезапусками. Для хранения данных между Pod-ами и их перезапусками используются Kubernetes Volumes.

**Пример использования volume:**

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: pod-with-volume
spec:
  containers:
    - name: busybox
      image: busybox
      command: ["sleep", "3600"]
      volumeMounts:
        - mountPath: "/data"
          name: my-storage
  volumes:
    - name: my-storage
      emptyDir: {}
# Здесь /data будет точкой монтирования временного хранилища для этого Pod
```

Вы также можете подключать внешние хранилища — например, файловые системы облачных провайдеров.

### ConfigMap и Secret

**ConfigMap** — хранит текстовые конфигурации, которые можно подключать к Pod-ам, не встраивая в контейнер.

**Secret** — похоже на ConfigMap, но применяется для хранения чувствительных данных (например, паролей), содержимое кодируется в base64.

**Пример ConfigMap:**

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: example-config
data:
  APP_ENV: production
```

### Автоматизация задач с помощью Controllers

Controllers — это процессы, которые работают в Control Plane и обеспечивают желаемое состояние объектов. Например, если Deployment должен содержать 3 Pod-а, а один из них неожиданно завершился — контроллер тут же создаст новый.

### Масштабирование и обновления

Kubernetes позволяет масштабировать приложения в одну команду:

```bash
kubectl scale deployment/nginx-deployment --replicas=6
# Теперь работает 6 экземпляров приложения
```

А обновлять контейнеры можно к атомарно с помощью:

```bash
kubectl set image deployment/nginx-deployment nginx=nginx:1.26
# Начнется rolling update — поочередная замена старых Pod на новые
```

## Как Kubernetes orchestrates (управляет) контейнерами

Смотрите, весь оркестратор работает по принципу "указание желаемого состояния". Вы объявляете, что "у меня должно быть 5 экземляров приложения X", а Kubernetes сам поддерживает это состояние: размещает, перемещает, перезапускает контейнеры по мере необходимости.

- Если узел "упал" — контейнеры переедут на другие узлы.
- Если нагрузка выросла — можно легко добавить еще копий.
- Если нужно доставить обновление — оно проходит поочередно, чтобы сохранялась доступность сервиса.

Контроллеры реагируют на события и изменения состояния, делают автолечение (self-healing), масштабируют приложения, обеспечивают балансировку, и все это происходит автоматически.

## Практические примеры запуска приложения в Kubernetes

### 1. Запуск Pod с помощью манифеста

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: hello-pod
spec:
  containers:
  - name: hello
    image: busybox
    command: ['sh', '-c', 'echo "Hello, Kubernetes!" && sleep 3600']
# Этот Pod выведет сообщение и заснет на час
```
Создайте файл hello-pod.yaml и запустите:

```bash
kubectl apply -f hello-pod.yaml
```

### 2. Запуск Deployment

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: app-deployment
spec:
  replicas: 2
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
    spec:
      containers:
      - name: myapp
        image: yourname/yourapp:latest
```
Показываю вам пример описания деплоймента сразу с двумя репликами.

### 3. Просмотр и управление объектами Kubernetes

```bash
kubectl get pods # Список подов
kubectl get deployments # Список деплойментов
kubectl get services # Сервисы
kubectl describe pod hello-pod # Детальное описание пода

kubectl delete pod hello-pod # Удалить под
```

### 4. Масштабирование приложения

```bash
kubectl scale deployment/app-deployment --replicas=5
# Масштабируем до пяти экземпляров
```

### 5. Взаимодействие между Pod-ами

Часто возникает вопрос: как один Pod может общаться с другим? Обычно через сервисы. Kubernetes автоматически создает для сервиса DNS-имя — просто обращайтесь к нему по имени сервиса, например, `http://nginx-service`.

### 6. Обновление приложения без простоя

Kubernetes поддерживает rolling updates. Вот как это выглядит:

```bash
kubectl set image deployment/app-deployment myapp=yourname/yourapp:v2
# Обновится образ контейнера - новые поды развернутся поочередно
```

## Безопасность и ограничения прав

Kubernetes реализует гибкую RBAC (Role-Based Access Control). С ее помощью можно разделять права между пользователями и сервисными аккаунтами, выдавая только необходимые полномочия. Также можно изолировать ресурсы через Namespaces.

## Интеграция с экосистемой DevOps

Kubernetes легко интегрируется с CI/CD пайплайнами, системами логирования (например, ELK или Loki), мониторингом (Prometheus, Grafana) и инструментами для обнаружения сервисов. С его помощью автоматизируется практически весь цикл разработки и эксплуатации приложений.

## Заключение

Kubernetes сегодня — это ключевой инструмент для организации масштабируемой, гибкой и автоматизированной ИТ-инфраструктуры в облаке или на собственных серверах. Он позволяет запускать приложения в изолированных контейнерах, динамически распределять нагрузку между ними, автоматически масштабировать и обновлять сервисы без прерывания работы системы. Вы описываете, как должен выглядеть ваш сервис — Kubernetes берет на себя всю рутину по поддержанию этого состояния.

Если вы хотите работать с современными распределенными системами, ускорить процесс разработки и повысить надежность своих приложений — Kubernetes станет для вас отличным помощником.

## Частозадаваемые технические вопросы по Kubernetes

### Как получить доступ к Pod для отладки и посмотреть его логи?

Используйте следующие команды:

```bash
kubectl logs my-pod
# Просмотр логов контейнера

kubectl exec -it my-pod -- /bin/sh
# Запустить shell внутри контейнера для отладки
```

### Как ограничить использование ресурсов (CPU, RAM) для пода?

В манифесте Pod или Deployment добавьте секцию ресурсов:

```yaml
resources:
  requests:
    memory: "128Mi"
    cpu: "250m"
  limits:
    memory: "256Mi"
    cpu: "500m"
# Здесь указаны минимальные и максимальные значения для памяти и процессора
```

### Как удалять неиспользуемые ресурсы (pod, service, deployment)?

Удаление осуществляется так:

```bash
kubectl delete pod имя-пода
kubectl delete deployment имя-деплоймента
kubectl delete service имя-сервиса
```

### Как быстро проверить работоспособность всех компонентов кластера?

Проверьте статусы всех узлов и компонентов:

```bash
kubectl get nodes
kubectl get pods --all-namespaces
kubectl get componentstatus
```

### Как создать свой Docker-образ и запустить его в Kubernetes?

1. Создайте Dockerfile и соберите образ:  
   `docker build -t yourname/yourapp:v1 .`
2. Отправьте образ в Docker Hub или другую реестру:
   `docker push yourname/yourapp:v1`
3. Используйте этот образ в вашм манифесте Deployment, например:
   ```yaml
   containers:
     - name: myapp
       image: yourname/yourapp:v1
   ```
4. Примените манифест через `kubectl apply`.

Эти инструкции помогут быстрее разобраться с распространенными задачами при работе с Kubernetes.