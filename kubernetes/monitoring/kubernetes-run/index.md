---
metaTitle: Использование команды Run в Kubernetes
metaDescription: Здесь вы узнаете как использовать команду run в Kubernetes - разберете синтаксис, опции, сценарии и эффективные подходы для быстрого старта контейнеров и отладки
author: Олег Марков
title: Использование команды Run в Kubernetes
preview: Погрузитесь в практику работы с kubectl run - научитесь быстро запускать контейнеры, управлять опциями и конфигурацией, отлаживать приложения и автоматизировать тестирование
---

## Введение

Когда вы только начинаете знакомство с Kubernetes, запуск приложений в кластере может показаться сложным процессом из-за обилия YAML-манифестов и настроек. Но есть команда, которая часто становится первой, с которой сталкиваются разработчики и девопсы — это `kubectl run`. Она позволяет вам быстро развернуть контейнер в кластере без необходимости писать длинные конфигурационные файлы. В этой статье я расскажу, как эффективно использовать команду `run` в Kubernetes: объясню синтаксис, типичные сценарии, сильные и слабые стороны, а также реальные примеры и советы по применению.

## Что такое команда kubectl run

Команда `kubectl run` — это упрощённый способ создать и запустить экземпляр (Pod) вашего контейнерного приложения прямо из командной строки Kubernetes. Она изначально задумывалась как инструмент для быстрой генерации Pod — запуск однократных или одноразовых задач, а также для удобной отладки.

Ранее (до версии 1.18 Kubernetes) эта команда умела генерировать Deployment, ReplicaSet и Job, однако с более свежими версиями Kubernetes её функциональность была сужена из соображений безопасности и явности процессов развертывания.

## Возможности kubectl run

### Основная задача

С помощью `kubectl run` вы можете:

- Запустить Pod из указанного образа контейнера
- Задать параметры окружения, пробросить порт, ограничить ресурсы
- Быстро проверить запуск/работу контейнера без создания YAML файла
- Поднимать Job (для разовых задач) с помощью специальных флагов
- Осуществлять отладку при помощи интерактивного запуска контейнера с подключением к терминалу

### Когда использовать kubectl run

- Для быстрого прототипирования и тестирования работы контейнера
- Для первоначальной настройки и отладки образа
- В автоматизации CI/CD пайплайнов, когда не требуется хранить описание ресурсов в файле
- Для разовых команд и скриптов, где не нужен долгоживущий объект

Не стоит использовать `kubectl run` для управления production-нагрузкой или в качестве полноценного инструмента оркестрации — для этого лучше использовать манифесты Deployment, StatefulSet и т.д.

## Синтаксис и основные параметры kubectl run

Давайте рассмотрим базовую структуру команды и самые популярные параметры.

```bash
kubectl run <имя-pod> --image=<имя-образа> [опции]
```

- `<имя-pod>` — задает имя вашего Pod
- `--image` — указывает имя образа контейнера (например, nginx, busybox, custom-repo/myapp:tag)
- [опции] — дополнительные параметры (порт, переменные среды, команды и прочее)

Пример самого простого запуска:

```bash
kubectl run test-nginx --image=nginx
# Запускает Pod с именем test-nginx из официального образа nginx
```

### Популярные опции команды run

- `--restart`: определяет тип создаваемого объекта (по-умолчанию всегда Pod, возможны Job, Never)
- `--command` и далее команда: переопределяет команду запуска в контейнере
- `--env`: задаёт переменные среды
- `--rm`: удаляет Pod после завершения работы (подходит для мелких задач и тестов)
- `-i`, `--tty`: создают интерактивный терминал (часто применяется для отладки)
- `--port`: пробрасывает порт
- `--labels`: задаёт метки объекту
- `--limits` и `--requests`: ресурсные ограничения

Давайте рассмотрим это на примерах.

### Пример запуска с параметрами

```bash
kubectl run busybox-demo --image=busybox --env="DEMO=123" --command -- sleep 3600
# Создаёт Pod busybox-demo из образа busybox, задаёт переменную среды DEMO и запускает sleep на 1 час
```

### Пример для интерактивной отладки

```bash
kubectl run debug-pod --image=busybox -i --tty --rm -- /bin/sh
# Запускает интерактивную шелл-сессию и удаляет Pod после выхода
```
Здесь вы получаете полноценный bash доступ к контейнеру, а Pod автоматически исчезает после завершения сессии.

### Пример задания портов

```bash
kubectl run my-nginx --image=nginx --port=80
# Создаёт Pod с пробросом порта 80 (используется для генерации сервисов, хотя в последних версиях только для аннотаций)
```

### Пример создания одноразовой задачи

```bash
kubectl run job-demo --image=busybox --restart=OnFailure -- echo "Hello, Kubernetes!"
# Поднимет Job вместо обычного Pod, выполнение завершится после вывода текста
```
Вы видите, что ключ `--restart=OnFailure` меняет природу объекта с Pod на Job, что бывает полезно для задач с финальной точкой завершения.

## Получение информации о запущенных объектах

Для управления, мониторинга и просмотра результатов существуют отдельные команды.

#### Список запущенных Pod

```bash
kubectl get pods
```
Показывает все ваши Pod в текущем namespace.

#### Просмотр логов

```bash
kubectl logs <имя-pod>
# Показывает вывод стандартного потока stdout/stderr контейнера
```

#### Проверка статуса

```bash
kubectl describe pod <имя-pod>
# Более детальный вывод по объекту, описание статуса, событий и привязки ресурсов.
```

#### Остановка или удаление

```bash
kubectl delete pod <имя-pod>
# Позволяет принудительно удалить Pod по имени
```

## Практика: запуск и отладка контейнеров

Теперь я покажу вам реальные сценарии, где приложение команды `run` позволяет быстро и удобно решать задачи.

### Более сложные переменные среды

```bash
kubectl run env-check --image=alpine --env="FOO=bar" --env="BAR=baz" -- /bin/sh -c 'echo $FOO-$BAR && sleep 10'
# Происходит запуск Alpine с выводом FOO и BAR, затем пауза 10 секунд
```
Можно быстро проверить взаимодействие с переменными окружения.

### Ввод пользовательских команд

```bash
kubectl run tool-pod --image=alpine --command -- /bin/sh -c "apk update && apk add curl && curl ifconfig.me"
# Запускает контейнер с установкой curl и выводом текущего внешнего IP
```
Это поможет, если нужно прогнать быструю проверку сетевых инструментов, доступности API, отладки DNS и т.д.

### Использование init-контейнеров и volume (ограничено)

Команда `kubectl run` не поддерживает более сложные конструкции вроде volume, initContainers напрямую. Для этого потребуется перейти к манифестам (YAML), но для простых тестов это почти всегда избыточно.

## Отличия и ограничения команды kubectl run

### Современное использование

В ранних версиях `kubectl run` умел создавать развертывания (Deployment), сервисы, конфигурировать управление масштабом и обновлениями. Сейчас — только Pod или Job (при flags).

Это сделано специально, чтобы вынудить вас явно описывать StatefulSet/Deployment/ReplicaSet руками и не путать ephemeral-поднимаемые задачи и production-ready объекты.

### Когда команда run бесполезна

- Для сложных сценариев деплоя
- Для автоматического масштабирования и zero-downtime (используйте Deployment)
- Для настройки монтирования томов
- Для запуска нескольких контейнеров в одном Pod (multi-container pod)

Здесь уже потребуется подготовить манифесты.

### Советы по безопасности

Если вы указали интерактивный запуск с терминалом (`--tty -i`), не отпускайте такие Pod в production — они открывают внутри кластера «shell», а если образ доверять нельзя — возможно перехват управления.

Никогда не запускайте контейнеры с повышенными правами или с корневым доступом через `run` без необходимости, особенно если вы тестируете что-то из интернета!

## Автоматизация и использование в CI/CD

В CI/CD пайплайнах команду kubectl run удобно применять для:

- Временных тестовых сред
- Быстрых миграций (задачи типа миграции базы через Job)
- Прогона быстрого smoke-теста

Пример для запуска и ожидания успешного завершения миграции:

```bash
kubectl run migrate-job --image=myapp:latest --restart=OnFailure -- /app/migrate-db.sh
kubectl wait --for=condition=complete job/migrate-job --timeout=120s
```
Здесь скрипт подчинился в job, а вторая команда ждёт завершения. Такая связка полезна для атомарности операций.

## Советы при работе с командой kubectl run

- Не бойтесь экспериментировать — запуск контейнеров из чужих образов будет изолирован внутри Pod, пока нет volume-монтирований и сервис-аккаунтов с правами.
- Очищайте тестовые Pod (`--rm` или `kubectl delete pod ...`), чтобы не засорять пространство.
- Знакомьтесь с ограничениями версии вашей kubectl (в новых командах некоторые параметры недоступны).
- Проверяйте exit code Pod (`kubectl get pod ... -o yaml | grep exitCode`) чтобы удостовериться в успехе теста.

## Переход к полноценным манифестам

Когда явно не хватает простоты команды run, логично сделать манифест. Получить YAML генерацию можно при помощи:

```bash
kubectl run mypod --image=nginx --dry-run=client -o yaml > pod.yaml
# Генерирует готовый YAML-файл для будущей доработки
```

Доработайте его и применяйте через `kubectl apply -f pod.yaml`.

## Заключение

Команда `kubectl run` — это быстрый и интуитивно понятный инструмент для начального знакомства с Kubernetes, а также для оперативного запуска и отладки контейнеров в кластере. Она не призвана заменить комплексное управление приложениями через манифесты и деплойменты, но отлично справляется с ролью среды для тестов, прототипирования и отладки. Важно помнить об ограничениях и нюансах работы команды run, чтобы не сталкиваться с неожиданностями, особенно в продакшен средах.

---

## Частозадаваемые технические вопросы по теме статьи и ответы на них

### Вопрос 1: Как ограничить потребление ресурсов (CPU и память) при запуске Pod через kubectl run?

**Ответ:**  
Вы можете указать лимиты на CPU и память через параметр `--limits` и запрос через `--requests`. Пример:

```bash
kubectl run demo --image=nginx --limits=cpu=100m,memory=128Mi --requests=cpu=50m,memory=64Mi
# Лимитирует потребление 100 милли-CPU и 128Мб памяти
```

### Вопрос 2: Как передать несколько переменных окружения одновременно?

**Ответ:**  
Для задания нескольких переменных добавьте несколько флагов `--env`:

```bash
kubectl run env-demo --image=alpine --env=FOO=bar --env=BAR=baz -- /bin/sh -c 'echo $FOO-$BAR'
```

### Вопрос 3: Как пробросить volume или подключить ConfigMap при запуске через kubectl run?

**Ответ:**  
Напрямую подключить volume или ConfigMap нельзя. Для этого сгенерируйте YAML с помощью `--dry-run=client -o yaml` и доработайте его вручную, затем примените через `kubectl apply -f`.

### Вопрос 4: Как указать namespace при запуске команды kubectl run?

**Ответ:**  
Используйте флаг `-n` или `--namespace`:

```bash
kubectl run mypod --image=nginx -n my-namespace
```

### Вопрос 5: Как попасть в уже запущенный Pod с shell доступом?

**Ответ:**  
Используйте команду `kubectl exec`:

```bash
kubectl exec -it <pod-name> -- /bin/sh
# -it для интерактивного терминала в контейнере
```
Если в Pod несколько контейнеров, добавьте `-c <container-name>`.