---
metaTitle: Работа с преобразованием типов в Golang
metaDescription: Разбираемся c преобразованием типов в Golang
author: Александр Гольцман
title: Преобразование типов в Golang
preview: В этой статье я расскажу, как работает преобразование типов в Go, какие есть правила, и покажу на примерах, как правильно менять тип данных без неожиданных ошибок.
---

В языке программирования Go строгая типизация, что означает, что переменные и выражения имеют фиксированный тип, и автоматическое приведение типов происходит не всегда. Это повышает безопасность кода, но требует явного преобразования в нужные типы, когда это необходимо. В этой статье я расскажу, как работает преобразование типов в Go, какие есть правила, и покажу на примерах, как правильно менять тип данных без неожиданных ошибок.

## **Зачем нужно преобразование типов?**

При работе с данными в Go часто возникает необходимость привести один тип к другому. Например, у вас может быть число в виде строки, которое нужно преобразовать в `int`, или целое число, которое требуется представить в `float64` для точных вычислений.

Преобразование типов в Go решает несколько задач:

- **Корректная работа с разными типами данных** — например, арифметические операции должны выполняться между числами одного типа.
- **Чтение и запись данных** — текстовые форматы (JSON, CSV) хранят числа как строки, и их нужно преобразовывать в числовые типы.
- **Совместимость API** — иногда библиотеки и функции требуют данные определенного типа.

Go требует явного преобразования между несоответствующими типами, чтобы избежать скрытых ошибок.

## **Преобразование числовых типов**

В Go можно преобразовывать числовые типы друг в друга с помощью синтаксиса:

```go
var x int = 42
var y float64 = float64(x) // Преобразование int в float64
var z uint = uint(x)       // Преобразование int в uint
```

Смотрите, здесь нет автоматического преобразования, как в других языках. Например, сложение `int` и `float64` вызовет ошибку:

```go
var a int = 10
var b float64 = 5.5
// fmt.Println(a + b) // Ошибка: mismatched types int and float64
```

Чтобы код работал, нужно привести `a` к `float64`:

```go
fmt.Println(float64(a) + b) // Выведет 15.5
```

## **Преобразование строк и чисел**

Иногда данные приходят в виде строк, и их нужно преобразовать в числа. Для этого в пакете `strconv` есть функции:

- `strconv.Atoi(s string) (int, error)` — преобразует строку в `int`.
- `strconv.ParseFloat(s string, bitSize int) (float64, error)` — преобразует строку в `float64`.
- `strconv.Itoa(i int) string` — преобразует `int` в строку.

Пример:

```go
import (
    "fmt"
    "strconv"
)

func main() {
    s := "123"
    n, err := strconv.Atoi(s)
    if err != nil {
        fmt.Println("Ошибка:", err)
        return
    }
    fmt.Println(n + 10) // Выведет 133

    f := 3.14
    str := strconv.FormatFloat(f, 'f', 2, 64)
    fmt.Println(str) // "3.14"
}
```

Здесь `strconv.Atoi` преобразует строку `"123"` в число, а `strconv.FormatFloat` превращает число `3.14` обратно в строку с двумя знаками после запятой.

## **Преобразование `interface{}` и `type assertion`**

Go поддерживает пустой интерфейс `interface{}`, который может хранить значения любого типа. Чтобы извлечь конкретный тип из `interface{}`, используется `type assertion`:

```go
var i interface{} = "Hello"
s, ok := i.(string)
if ok {
    fmt.Println(s) // "Hello"
} else {
    fmt.Println("Преобразование не удалось")
}
```

Если тип не соответствует, без `ok` программа вызовет панику.

## **Преобразование `struct` и `map` в JSON**

При работе с API и файлами часто нужно преобразовывать структуры в JSON и обратно. В Go для этого есть пакет `encoding/json`:

```go
import (
    "encoding/json"
    "fmt"
)

type User struct {
    Name string `json:"name"`
    Age  int    `json:"age"`
}

func main() {
    user := User{Name: "Alice", Age: 25}
    data, _ := json.Marshal(user)
    fmt.Println(string(data)) // {"name":"Alice","age":25}

    var newUser User
    json.Unmarshal(data, &newUser)
    fmt.Println(newUser.Name) // "Alice"
}
```

Здесь `json.Marshal` превращает структуру в JSON-строку, а `json.Unmarshal` преобразует её обратно в `struct`.

## **Заключение**

Преобразование типов в Go требует явного указания и подчиняется строгим правилам. Это делает код более предсказуемым и безопасным, исключая неожиданные приведения, как в динамически типизированных языках.

Здесь я показал ключевые техники: работу с числами, строками, `interface{}` и JSON. Важно помнить, что преобразование не всегда возможно, поэтому стоит обрабатывать ошибки, особенно при работе со строками и `interface{}`.

Используйте встроенные инструменты Go, такие как `strconv`, `json` и `type assertion`, и ваш код будет безопасным и понятным.
