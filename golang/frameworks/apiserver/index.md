---
metaTitle: API-сервер в Golang
metaDescription: Разбираемся с API-серверами в (api) в языке программирования Go (Golang).
author: Александр Гольцман
title: API-сервер в Golang
preview: В этой статье я покажу основные принципы работы API-сервера в Go: настройку маршрутов, обработку запросов и отправку JSON-ответов.
---

# **API-сервер в Golang**

API-сервер — это ключевой компонент в разработке веб-приложений и микросервисов. Он обрабатывает запросы клиентов, взаимодействует с базами данных и отправляет ответы в формате JSON. В языке Go API-сервер можно построить с использованием стандартной библиотеки `net/http` или сторонних фреймворков.

В этой статье я покажу основные принципы работы API-сервера в Go: настройку маршрутов, обработку запросов и отправку JSON-ответов.

## **Основные концепции API-сервера**

API-сервер строится вокруг трех ключевых элементов:

- **Маршруты (routes)** – определяют, какие URL-адреса обрабатывает сервер и какие функции вызываются в ответ на запросы.
- **Обработчики (handlers)** – функции, выполняющие логику обработки запросов (например, получение данных, их изменение или удаление).
- **Ответы (responses)** – данные, которые сервер отправляет клиенту, чаще всего в формате JSON.

Golang предлагает встроенные возможности для создания HTTP-серверов, но в реальных проектах часто используют дополнительные библиотеки для удобной маршрутизации и обработки запросов.

## **Запуск простого API-сервера**

В стандартной библиотеке Go есть пакет `net/http`, который позволяет быстро поднять сервер:

```go
package main

import (
    "fmt"
    "net/http"
)

func handler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintln(w, "Добро пожаловать в API!")
}

func main() {
    http.HandleFunc("/", handler) // Регистрация маршрута
    http.ListenAndServe(":8080", nil) // Запуск сервера на порту 8080
}

```

Этот сервер обрабатывает запросы на корневой маршрут `/` и возвращает простое текстовое сообщение.

## **Работа с HTTP-методами**

API-сервер должен поддерживать несколько типов запросов:

- **GET** – получение данных, например, списка пользователей.
- **POST** – отправка данных на сервер (создание новой записи).
- **PUT/PATCH** – обновление данных.
- **DELETE** – удаление записей.

Пример обработки разных методов запроса:

```go
func handler(w http.ResponseWriter, r *http.Request) {
    switch r.Method {
    case http.MethodGet:
        fmt.Fprintln(w, "Получен GET-запрос")
    case http.MethodPost:
        fmt.Fprintln(w, "Получен POST-запрос")
    default:
        http.Error(w, "Метод не поддерживается", http.StatusMethodNotAllowed)
    }
}

```

Смотрите, здесь мы добавили простую проверку метода запроса и отправляем разные ответы в зависимости от него.

## **Отправка JSON-ответов**

В API-сервере данные обычно передаются в формате JSON. Golang имеет встроенные инструменты для работы с JSON, включая пакет `encoding/json`.

Вот пример обработки запроса и возврата JSON-ответа:

```go
import (
    "encoding/json"
    "net/http"
)

type Response struct {
    Message string `json:"message"`
}

func jsonHandler(w http.ResponseWriter, r *http.Request) {
    response := Response{Message: "Привет, это JSON-ответ"}
    json.NewEncoder(w).Encode(response)
}

```

Этот обработчик создаёт структуру `Response` и отправляет её клиенту в формате JSON.

## **Маршрутизация с `gorilla/mux`**

Хотя `net/http` позволяет регистрировать маршруты, в сложных API удобнее использовать сторонние библиотеки. Одна из самых популярных — `gorilla/mux`.

```go
import (
    "github.com/gorilla/mux"
)

router := mux.NewRouter()
router.HandleFunc("/api", handler).Methods("GET", "POST")

```

Здесь маршрутизатор позволяет удобно управлять разными HTTP-методами.

## **Заключение**

В этой статье я показал, как устроен API-сервер в Go, начиная от простого HTTP-сервера до обработки JSON и маршрутизации. Golang предлагает встроенные инструменты для работы с HTTP, но для удобства можно использовать `gorilla/mux`, `Gin` или `Fiber`.

Если вам нужен быстрый и минималистичный сервер, можно использовать стандартную библиотеку. Если API-сервер должен быть гибким и масштабируемым, стоит обратить внимание на фреймворки, которые добавляют удобные инструменты для работы с запросами, логированием и middleware.
