---
metaTitle: Чтение и запись файлов (os, ioutil) в Golang
metaDescription: Разбираемся с чтением и записью файлов (os, ioutil) в языке программирования Go (Golang).
author: Александр Гольцман
title: Чтение и запись файлов в Golang
preview: В этой статье я расскажу, как в Go работать с файлами, какие подходы существуют, и на что стоит обратить внимание.
---

# **Чтение и запись файлов в Go**

Работа с файлами — одна из ключевых задач в программировании. В языке Go для этого предусмотрен пакет `os`, который предоставляет удобные методы для создания, чтения, записи и удаления файлов.

Файлы используются в самых разных ситуациях: от хранения конфигурационных данных до логирования событий и работы с большими массивами информации. Однако не всегда очевидно, какой метод чтения или записи выбрать в зависимости от размера файла и требований к производительности.

В этой статье я расскажу, как в Go работать с файлами, какие подходы существуют, и на что стоит обратить внимание. Я также разберу примеры кода, сопровождая их пояснениями, чтобы вам было проще понять, как применять эти техники в реальных проектах.

Работа с файлами в Golang включает в себя использование пакетов `os` и `ioutil`. Чтобы успешно читать и записывать файлы, важно понимать, как работают потоки ввода-вывода, как обрабатывать ошибки и как управлять ресурсами. Если вы хотите детальнее погрузиться в основы языка Go и заложить прочный фундамент для работы с файлами и другими операциями ввода-вывода — приходите на наш большой курс [Основы Golang](https://purpleschool.ru/course/go-basics?utm_source=knowledgebase&utm_medium=text&utm_campaign=chtenie-i-zapis-faylov-v-golang). На курсе 193 уроков и 16 упражнений, AI-тренажеры для безлимитной практики с кодом и задачами 24/7, решение задач с живым ревью наставника, еженедельные встречи с менторами.

## **Как читать файлы в Go**

### **Чтение всего файла целиком**

Если нам нужно загрузить файл в память полностью, проще всего использовать `os.ReadFile()`. Это удобный способ получить содержимое файла в виде байтового среза, после чего можно преобразовать его в строку и обработать.

```go
package main

import (
    "fmt"
    "os"
)

func main() {
    data, err := os.ReadFile("example.txt")
    if err != nil {
        fmt.Println("Ошибка чтения файла:", err)
        return
    }

    fmt.Println("Содержимое файла:")
    fmt.Println(string(data))
}
```

В этом коде мы используем `os.ReadFile()`, который открывает файл, считывает его содержимое в память и закрывает. Это удобный способ, но он подходит только для небольших файлов, так как при больших объемах данных может привести к чрезмерному потреблению памяти.

Обратите внимание, что `os.ReadFile()` возвращает данные в виде среза байтов (`[]byte`), поэтому их необходимо преобразовать в строку перед выводом. Также, если файла не существует или у программы нет прав доступа, возникнет ошибка, которую мы обрабатываем в блоке `if err != nil`.

### **Чтение файла построчно**

Когда файл большой, загружать его целиком в память неэффективно. В таком случае лучше использовать **буферизированное чтение** с `bufio.Scanner()`, который позволяет считывать файл построчно.

```go
package main

import (
    "bufio"
    "fmt"
    "os"
)

func main() {
    file, err := os.Open("example.txt")
    if err != nil {
        fmt.Println("Ошибка открытия файла:", err)
        return
    }
    defer file.Close()

    scanner := bufio.NewScanner(file)
    for scanner.Scan() {
        fmt.Println(scanner.Text())
    }

    if err := scanner.Err(); err != nil {
        fmt.Println("Ошибка чтения файла:", err)
    }
}
```

Этот способ экономит память, так как в каждый момент времени в оперативной памяти хранится только одна строка файла. Это делает `bufio.Scanner()` отличным выбором для обработки больших логов или CSV-файлов.

Важно всегда закрывать файл после использования, чтобы избежать утечек ресурсов. В Go для этого удобно использовать `defer file.Close()`. Также в конце работы мы проверяем, не возникли ли ошибки во время чтения с `scanner.Err()`.

## **Запись данных в файл**

### **Перезапись файла (создание нового)**

Для записи данных в файл можно использовать `os.WriteFile()`. Если файл существует, его содержимое будет полностью заменено новыми данными.

```go
package main

import (
    "fmt"
    "os"
)

func main() {
    data := "Привет, Golang!"

    err := os.WriteFile("example.txt", []byte(data), 0644)
    if err != nil {
        fmt.Println("Ошибка записи файла:", err)
    }
}
```

В этом коде мы записываем строку `"Привет, Golang!"` в файл `example.txt`. Функция `os.WriteFile()` создает новый файл, если его не существует, и записывает переданные данные.

Файл создается с правами `0644`, что означает, что владелец может его читать и записывать, а другие пользователи — только читать. Записываемые данные передаются в виде `[]byte`, поэтому строку необходимо преобразовать перед записью.

Этот метод удобен, но он **удаляет** предыдущее содержимое файла, так что если вам нужно добавить данные, используйте `os.OpenFile()` с режимом `os.O_APPEND`.

### **Добавление данных в файл**

Если вам необходимо не перезаписывать файл, а дописывать в него новые строки, следует открывать файл в режиме `os.O_APPEND`.

```go
package main

import (
    "fmt"
    "os"
)

func main() {
    file, err := os.OpenFile("example.txt", os.O_APPEND|os.O_WRONLY, 0644)
    if err != nil {
        fmt.Println("Ошибка открытия файла:", err)
        return
    }
    defer file.Close()

    _, err = file.WriteString("\nДополнительный текст")
    if err != nil {
        fmt.Println("Ошибка записи файла:", err)
    }
}
```

Здесь файл открывается с флагом `os.O_APPEND`, что гарантирует, что новые данные добавятся в конец. Если файла нет, возникнет ошибка, так как `os.OpenFile()` в этом режиме **не создает новый файл**.

## **Работа с бинарными файлами**

Чтение и запись бинарных файлов (например, изображений или видео) практически не отличаются от работы с текстовыми файлами, за исключением того, что данные не преобразуются в строки.

```go
package main

import (
    "fmt"
    "os"
)

func main() {
    data, err := os.ReadFile("image.png")
    if err != nil {
        fmt.Println("Ошибка чтения файла:", err)
        return
    }

    err = os.WriteFile("copy.png", data, 0644)
    if err != nil {
        fmt.Println("Ошибка записи файла:", err)
    }
}
```

В этом коде изображение `image.png` читается в срез байтов, после чего его можно записать в новый файл `copy.png`. Этот метод удобен для небольших файлов, но если нужно обработать большие файлы, лучше использовать **потоковое чтение и запись**.

## **Удаление файлов**

Файл можно удалить с помощью `os.Remove()`:

```go
err := os.Remove("example.txt")
if err != nil {
    fmt.Println("Ошибка удаления файла:", err)
}
```

Этот метод навсегда удаляет файл, и если он был удален по ошибке, восстановить его средствами Go уже не получится. Поэтому будьте осторожны при использовании этой функции.

## **Заключение**

Работа с файлами в Go реализована лаконично и удобно. В зависимости от задачи можно выбрать подходящий способ чтения и записи:

- `os.ReadFile()` и `os.WriteFile()` — простые функции для небольших файлов.
- `bufio.Scanner()` — идеальный инструмент для построчного чтения больших файлов.
- `os.OpenFile()` с `os.O_APPEND` — лучший выбор для добавления данных в файл.
- При работе с бинарными файлами важно помнить, что их содержимое передается в виде `[]byte`, и его не нужно преобразовывать в строки.

Главное правило при работе с файлами — **всегда закрывать их после использования**, чтобы избежать утечек ресурсов. Используйте `defer file.Close()`, и это избавит вас от многих проблем.
Теперь у вас есть полное представление о том, как в Go читать, записывать и удалять файлы. Попробуйте реализовать на практике разные сценарии и убедитесь, что работа с файлами в Go действительно удобна и эффективна.

Теперь, когда у вас есть представление о чтении и записи файлов в Golang, стоит задуматься о том, как обрабатывать большие файлы, как использовать буферизацию и как работать с различными форматами файлов. Чтобы систематизировать свои знания Go и научиться писать эффективный и надежный код для работы с файлами, обратите внимание на курс [Основы Golang](https://purpleschool.ru/course/go-basics?utm_source=knowledgebase&utm_medium=text&utm_campaign=chtenie-i-zapis-faylov-v-golang). В первых 3 модулях уже доступно бесплатное содержание — начните погружаться в Go прямо сегодня и станьте уверенным разработчиком.
