---
metaTitle: Использование директив в Vue и их расширенные возможности
metaDescription: Руководство по использованию директив в Vue - кастомные директивы, жизненный цикл, best practice и расширение стандартных возможностей на примерах
author: Олег Марков
title: Использование директив в Vue и их расширенные возможности
preview: Научитесь использовать стандартные и кастомные директивы в Vue, создавайте собственные решения и открывайте для себя новые подходы к реактивному DOM
---

## Введение

Vue.js — это современный фреймворк JavaScript для создания реактивных пользовательских интерфейсов. Одной из ключевых возможностей Vue являются директивы. Директивы позволяют декларативно связывать данные с DOM, изменять поведение элементов, а в некоторых случаях даже вмешиваться в низкоуровневые операции с DOM. В этой статье подробно рассмотрим не только стандартные директивы, но и узнаем о создании кастомных решений, о расширенном взаимодействии с жизненным циклом директив, плюс обратим внимание на best practices и возможные сложности. Я покажу вам, как извлечь максимум из этой мощной функциональности Vue.

## Что такое директивы в Vue

Директива в Vue — это специальный атрибут, который добавляет реактивное или особое поведение элементу DOM при его рендеринге. Все встроенные директивы начинаются с префикса `v-`. 

### Зачем используются директивы

- Реагируют на данные и изменяют DOM в зависимости от них.
- Позволяют повторно использовать логику на компонентах.
- Упрощают декларативный стиль кода в шаблонах.

## Основные стандартные директивы Vue

Vue поставляется с набором стандартных директив, которые покрывают большинство типовых задач. Вот наиболее используемые из них:

- `v-bind`
- `v-model`
- `v-if`, `v-else-if`, `v-else`
- `v-for`
- `v-show`
- `v-on`
- `v-pre`, `v-cloak`, `v-once`, `v-memo`

Давайте взглянем на примеры и разберём каждую подробнее.

Понимание основ и применения директив — важный навык для каждого Vue-разработчика. Однако, чтобы создавать сложные и масштабируемые приложения, необходимо также глубокое понимание компонентов, маршрутизации и управления состоянием. Если вы хотите получить комплексные знания и навыки в разработке Vue-приложений, приходите на наш большой курс [Vue.js 3, Vue Router и Pinia](https://purpleschool.ru/course/vuejs?utm_source=knowledgebase&utm_medium=article&utm_campaign=osnovy-i-primenenie-direktiv-v-vue). На курсе 173 уроков и 21 упражнение, AI-тренажеры для безлимитной практики с кодом и задачами 24/7, решение задач с живым ревью наставника, еженедельные встречи с менторами.

### v-bind

`v-bind` связывает атрибуты элемента с выражением Vue.

```js
<template>
  <img v-bind:src="imgUrl" v-bind:alt="imgAlt">
</template>

<script>
export default {
  data() {
    return {
      imgUrl: 'logo.png',
      imgAlt: 'Company logo'
    }
  }
}
</script>
```

Здесь `v-bind:src` устанавливает значение `imgUrl` как источник изображения.
Можно использовать сокращение :src вместо v-bind:src.

### v-model

Используется для двусторонней синхронизации данных с input, textarea и select.

```js
<template>
  <input v-model="message">
  <p>Вы ввели: {{ message }}</p>
</template>

<script>
export default {
  data() {
    return {
      message: ''
    }
  }
}
</script>
```

Когда пользователь вводит текст, `message` автоматически обновляется.

### v-if / v-else-if / v-else

Для условного рендеринга элементов.

```js
<template>
  <p v-if="isLoggedIn">Добро пожаловать!</p>
  <p v-else>Пожалуйста, войдите в систему.</p>
</template>

<script>
export default {
  data() {
    return {
      isLoggedIn: false
    }
  }
}
</script>
```

В зависимости от значения `isLoggedIn` показывается разный текст.

### v-for

Каждый раз, когда вам нужно повторить элемент для элементов массива или объекта, используйте эту директиву.

```js
<template>
  <ul>
    <li v-for="(user, index) in users" :key="user.id">
      {{ index + 1 }}. {{ user.name }}
    </li>
  </ul>
</template>

<script>
export default {
  data() {
    return {
      users: [
        { id: 1, name: "Анна" },
        { id: 2, name: "Иван" }
      ]
    }
  }
}
</script>
```

v-for работает с key, чтобы Vue оптимально отслеживал изменения списка.

### v-show

Прячет или отображает элемент с помощью CSS-свойства display, не удаляя его из DOM.

```js
<template>
  <button v-show="isVisible">Показать/Скрыть</button>
</template>
```

Отличие от v-if — элемент всегда в DOM, просто его невидно.

### v-on

Вешает обработчики на события.

```js
<template>
  <button v-on:click="handleClick">Нажми меня</button>
</template>

<script>
export default {
  methods: {
    handleClick() {
      // Реагируем на нажатие кнопки
      alert('Вы нажали на кнопку!')
    }
  }
}
</script>
```

Для краткости используйте @click.
  
### v-pre, v-cloak, v-once, v-memo

- `v-pre` — пропускает элемент и его потомков при компиляции Vue.
- `v-cloak` — используется для предотвращения мерцания некомпилированных шаблонов на этапе загрузки (обычно работает в связке с CSS).
- `v-once` — рендерит элемент один раз и не обновляет его при изменении данных.
- `v-memo` (Vue 3) — кеширует результат рендера для производительности.

## Кастомные директивы в Vue

В дополнение ко встроенным директивам вы можете создавать свои собственные, чтобы расширить функциональность приложения. Кастомные директивы часто используют для интерактивных манипуляций с DOM, которые не подходят для обработки через обычные пропсы или события.

### Простейший пример кастомной директивы

Создадим директиву, которая фокусирует input, когда компонент появляется на странице.

#### Глобальная регистрация

```js
// main.js
import { createApp } from 'vue'
import App from './App.vue'

// Регистрируем директиву глобально
const app = createApp(App)
app.directive('focus', {
  // Вызывается после вставки элемента в DOM
  mounted(el) {
    el.focus()
  }
})

app.mount('#app')
```

```js
<!-- Используем кастомную директиву -->
<input v-focus>
```

Теперь любой input с v-focus автоматически получает фокус.

#### Локальная регистрация директивы

Если вы хотите, чтобы директива была доступна только в конкретном компоненте:

```js
export default {
  directives: {
    focus: {
      mounted(el) {
        el.focus()
      }
    }
  }
}
```

Можно использовать в шаблоне компонента <input v-focus>.

### Директива с аргументом и модификатором

Vue позволяет указывать аргументы (например, название события или свойства) и модификаторы (например, `.once`, `.prevent`).

```js
<!-- Директива с аргументом и модификатором -->
<button v-my-directive:alert.once="message">Click</button>
```

В директиве это выглядит так:

```js
app.directive('my-directive', {
  mounted(el, binding) {
    // binding.arg — значение аргумента (alert)
    // binding.modifiers — объект модификаторов (например, { once: true })
    if (binding.arg === 'alert') {
      el.addEventListener('click', () => {
        alert(binding.value)
      }, { once: binding.modifiers.once })
    }
  }
})
```

Теперь кнопка вызовет alert с message и сделает это только один раз.

### Жизненный цикл кастомных директив

У директив есть свои хуки, похожие на жизненный цикл компонентов:

- `created` — вызывается при инициализации директивы.
- `beforeMount` — перед монтированием элемента.
- `mounted` — после монтирования.
- `beforeUpdate` — перед обновлением привязанного элемента.
- `updated` — после обновления элемента.
- `beforeUnmount` — перед удалением.
- `unmounted` — после удаления из DOM.

Вот как можно использовать эти хуки:

```js
app.directive('example', {
  created(el, binding, vnode, prevVnode) {
    // Логика при инициализации
  },
  beforeMount(el, binding, vnode, prevVnode) {
    // Перед вставкой в DOM
  },
  mounted(el, binding, vnode, prevVnode) {
    // Уже в DOM
  },
  beforeUpdate(el, binding, vnode, prevVnode) {
    // Перед повторным обновлением
  },
  updated(el, binding, vnode, prevVnode) {
    // После обновления
  },
  beforeUnmount(el, binding, vnode, prevVnode) {
    // Перед размонтированием
  },
  unmounted(el, binding, vnode, prevVnode) {
    // После удаления из DOM
  }
})
```

Обычно используют только mounted и unmounted, но для сложных случаев может понадобиться полный цикл.

### Пример: Кастомная директива для отслеживания клика вне элемента

Предположим, вам нужно закрывать меню по клику вне его области. Давайте решим эту задачу с помощью директивы.

```js
app.directive('click-outside', {
  mounted(el, binding) {
    el.__vueClickOutside__ = event => {
      // Проверяем, был ли клик вне нашего элемента
      if (!(el === event.target || el.contains(event.target))) {
        binding.value(event) // вызываем функцию, переданную директиве
      }
    }
    document.body.addEventListener('click', el.__vueClickOutside__)
  },
  unmounted(el) {
    // Чистим слушатель при удалении элемента из DOM
    document.body.removeEventListener('click', el.__vueClickOutside__)
    delete el.__vueClickOutside__
  }
})
```

```js
<template>
  <div v-click-outside="closeMenu">
    <!-- Ваше меню -->
  </div>
</template>

<script>
export default {
  methods: {
    closeMenu() {
      // Логика закрытия меню
    }
  }
}
</script>
```

Такой подход позволяет многократно использовать директиву в проекте без дублирования кода.

### Пример: Передача параметров через модификаторы

Иногда удобно передавать дополнительные настройки через модификаторы:

```js
<template>
  <button v-tooltip.top="'Вверхний тултип'">Наведи мышку</button>
  <button v-tooltip.bottom="'Нижний тултип'">Наведи мышку</button>
</template>
```

```js
app.directive('tooltip', {
  mounted(el, binding) {
    const position = binding.modifiers.top ? 'top' :
      binding.modifiers.bottom ? 'bottom' : 'right'
    el.addEventListener('mouseenter', () => {
      // Показать тултип в нужном положении
      showTooltip(el, binding.value, position)
    })
    el.addEventListener('mouseleave', () => {
      hideTooltip(el)
    })
  },
  unmounted(el) {
    // Чистим все слушатели и тултипы, если нужно
  }
})
```

Такой способ добавляет гибкости для переиспользуемых решений.

## Расширенные возможности и best practices работы с директивами

### Когда использовать директивы

- Если вам нужно напрямую манипулировать DOM-элементом.
- Когда требуется повторное использование точки расширения в шаблоне.
- Когда не хватает стандартных событий или реактивностей компонентов.

### Best practices

- Всегда чистите внешние ресурсы и слушателей событий в хуке `unmounted`.
- Не используйте директивы для логики, которую можно выразить обычными props, events или computed.
- Если ваша логика слишком сложна, подумайте о создании отдельного компонента, а не директивы.
- Используйте директивы для компактной интеграции сторонних библиотек, например, для автофокуса, drag’n’drop, кастомных тултипов и т.д.
- Всегда старайтесь избегать сайд-эффектов в директивах.

### Пример: Интеграция стороннего плагина через директиву

Допустим, вам нужно сделать маску ввода для телефона. Используйте библиотеку, которую удобно подключить через директиву.

```js
import Inputmask from "inputmask"

app.directive('inputmask', {
  mounted(el, binding) {
    Inputmask(binding.value).mask(el)
  },
  unmounted(el) {
    Inputmask.remove(el)
  }
})
```

```js
<template>
  <input v-inputmask="'+7 (999) 999-99-99'" type="text">
</template>
```

Такой подход позволяет повторно использовать директиву для разных инпутов без дублирования кода.

### Кратко про SSR

Некоторые директивы не будут корректно работать на серверном рендеринге (SSR), если они зависят от DOM API. Например, фокусировка, интеграция сторонних плагинов — такие действия корректно срабатывают только на этапе mounted, когда DOM уже доступен.

### Работа с Typescript

Если используете TypeScript, желательно расширять типы для кастомных директив, чтобы улучшить автодополнение и избежать ошибок во время разработки. Для более сложных директив можно объявлять типы из @vue/runtime-core или создать отдельные интерфейсы.

## Заключение

Директивы — это мощный инструмент для непосредственного управления поведением DOM в Vue-приложениях. Встроенные директивы закрывают большинство рутинных задач: работа с атрибутами, событиями, условным или циклическим выводом. Однако кастомные директивы открывают новые возможности управления элементами, упрощая интеграцию сторонних библиотек и реализацию типовых UI-паттернов, таких как клик вне элемента или маска ввода.

Использование директив требует понимания жизненного цикла и правильного управления ресурсами. Старайтесь следовать best practice, не использовать директивы вместо компонентной логики, но не бойтесь применять их для расширения стандартных возможностей Vue. Кастомные директивы остаются отличным способом минимизировать дублирование кода и повысить переиспользуемость решений.

Знание основ и применения директив, конечно, важно, но это лишь малая часть знаний, необходимых современному Vue разработчику. Для создания полноценных приложений необходимо также уметь управлять состоянием, организовывать маршрутизацию и взаимодействовать с сервером. На нашем курсе [Vue.js 3, Vue Router и Pinia](https://purpleschool.ru/course/vuejs?utm_source=knowledgebase&utm_medium=article&utm_campaign=osnovy-i-primenenie-direktiv-v-vue) вы найдете ответы на эти и многие другие вопросы. В первых 3 модулях уже доступно бесплатное содержание — начните погружаться в мир Vue прямо сегодня.

## Частозадаваемые технические вопросы по теме

### Как передать несколько параметров в директиву?

В параметр директивы можно передавать объект:
```js
<input v-my-directive="{ value: someValue, option: flag }">
```
Внутри директивы получаете это через `binding.value`.

### Как обращаться к данным компонента из кастомной директивы?

В директиве 4-го параметра `vnode` есть ссылка на инстанс компонента (`vnode.context` в Vue 2, в Vue 3 — используйте emit или provide/inject либо прокидывайте необходимые данные через prop директивы).

### Как использовать директиву во вложенных компонентах?

Локально зарегистрированная директива доступна только в том компоненте, где она объявлена. Чтобы применять во всех компонентах, регистрируйте директиву глобально через экземпляр приложения.

### Как протестировать кастомные директивы?

Используйте e2e или unit-тесты с Jest и @vue/test-utils. Можно смонтировать компонент с директивой и эмулировать события или изменения binding.value, далее проверять эффект над DOM.

### Можно ли использовать директиву с компонентами, а не только с DOM-элементами?

В большинстве случаев директивы применимы только к обычным HTML-элементам. В Vue 3 директивы нельзя навешивать на компоненты — только на raw DOM (исключение: если обертка компонента содержит single root DOM-элемент, можно попасть в этот элемент через ref или slot).
