---
metaTitle: Использование массивов и методов их обработки в Vue
metaDescription: Разберитесь с тем как работать с массивами во Vue — от отображения до реактивных методов и типичных ошибок при обработке данных
author: Олег Марков
title: Использование массивов и методов их обработки в Vue
preview: Научитесь обрабатывать массивы во Vue — подробно о рендеринге, добавлении, удалении и реактивности с живыми примерами кода
---

## Введение

Работа с массивами — одна из ключевых задач в разработке интерфейсов на Vue. Этот вопрос встречается буквально на каждом проекте: отображение списков, добавление и удаление элементов, сортировка, фильтрация, реактивное обновление отображаемых данных и многое другое. Vue предоставляет множество удобств для работы с массивами, сочетая простоту JavaScript с мощной системой реактивности. Здесь вы узнаете, как именно используются массивы во Vue, какие методы для их обработки существуют и как избежать типичных ошибок новичков.

## Основы отображения массивов во Vue

Давайте для начала разберёмся, как выводить массивы на страницу с помощью Vue. 

### Как вывести массив в шаблоне

Во Vue для отображения массивов чаще всего используют директиву `v-for`.

#### Пример вывода простого массива

```html
<ul>
  <li v-for="item in items" :key="item.id">
    {{ item.name }}
  </li>
</ul>
```

```js
data() {
  return {
    items: [
      { id: 1, name: 'Яблоко' },
      { id: 2, name: 'Банан' },
      { id: 3, name: 'Апельсин' }
    ]
  }
}
```

Здесь мы используем v-for для вывода массива объектов. :key нужен для оптимизации и правильного рендеринга списка.

### Директива v-for: синтаксис и нюансы

Директива `v-for` может принимать не только значение, но и индекс текущего элемента.

```html
<li v-for="(item, index) in items" :key="item.id">
  {{ index }} — {{ item.name }}
</li>
```

Индекс может пригодиться, если нужно вычислять позицию элемента в списке.

Используйте для key уникальные значения (часто id из объектов), чтобы Vue правильно управлял списком при изменениях.

Разбор работы с массивами во Vue — важный шаг для создания динамичных интерфейсов. Но для разработки сложных и поддерживаемых приложений, необходимо хорошее понимание компонентов, маршрутизации и управления состоянием. Если вы хотите получить комплексные знания и навыки в разработке Vue-приложений, приходите на наш большой курс [Vue.js 3, Vue Router и Pinia](https://purpleschool.ru/course/vuejs?utm_source=knowledgebase&utm_medium=article&utm_campaign=ispolzovanie-massivov-i-metodov-ih-obrabotki-v-vue). На курсе 173 уроков и 21 упражнение, AI-тренажеры для безлимитной практики с кодом и задачами 24/7, решение задач с живым ревью наставника, еженедельные встречи с менторами.

## Работа с массивами в реактивном состоянии

Vue автоматически делает массивы реактивными, когда вы объявляете их в `data`. Но есть нюансы.

### Добавление и удаление элементов

#### Добавление элемента

Добавим элемент кнопкой:

```html
<button @click="addItem">Добавить элемент</button>
<ul>
  <li v-for="item in items" :key="item.id">
    {{ item.name }}
  </li>
</ul>
```

```js
data() {
  return {
    items: [
      { id: 1, name: 'Яблоко' },
      { id: 2, name: 'Банан' }
    ],
    nextId: 3
  }
},
methods: {
  addItem() {
    // Добавляем новый элемент в массив
    this.items.push({ id: this.nextId++, name: `Продукт №${this.nextId - 1}` })
  }
}
```

// После вызова addItem массив и список на странице будут обновлены автоматически благодаря реактивности Vue.

#### Удаление элемента

Вам может понадобиться удалять элементы по индексу или по id:

```html
<li v-for="(item, index) in items" :key="item.id">
  {{ item.name }}
  <button @click="removeItem(index)">Удалить</button>
</li>
```

```js
methods: {
  removeItem(index) {
    // Удаляет элемент по индексу из массива
    this.items.splice(index, 1)
  }
}
```

Метод splice делает изменение реактивным.

## Популярные методы массивов и их правильное использование

Так как vue.js использует "чистый" JavaScript для работы с массивами, всё, что вы знаете о массивах в JavaScript, применимо и во Vue. Но из-за реактивности есть особенности, которые стоит учесть.

### Изменяющие методы

Методы, которые изменяют исходный массив (mutating):

- push — добавить элемент в конец
- pop — удалить элемент с конца
- shift — удалить элемент с начала
- unshift — добавить элемент в начало
- splice — добавить/удалить элемент в любой позиции
- sort — отсортировать массив
- reverse — изменить порядок элементов на противоположный

Vue отслеживает изменения, сделанные этими методами, и автоматически обновляет DOM.

#### Пример добавления/удаления с push/pop

```js
methods: {
  добавитьФрукт() {
    this.items.push({ id: this.nextId++, name: `Новый фрукт №${this.nextId - 1}` })
  },
  удалитьФрукт() {
    this.items.pop() // Убирает последний элемент
  }
}
```

### Неизменяющие методы

Эти методы создают новый массив, но оригинальный не трогают: filter, map, slice, concat.

#### Пример фильтрации

```js
computed: {
  толькоЯблоки() {
    // Возвращаем новый массив только с яблоками
    return this.items.filter(item => item.name === 'Яблоко')
  }
}
```

Фильтрация часто используется внутри вычисляемых свойств (computed) для реактивного отображения части массива.

## Реактивность массивов: нюансы и подводные камни

Реактивность — ключевая фишка Vue. Но есть моменты, о которых важно знать.

### Добавление или удаление по индексу

Если вы используете конструкцию вроде `this.items[2] = новыйОбъект` или напрямую меняете длину массива, Vue может не разглядеть эти изменения.

#### Как правильно задать новый элемент по индексу

```js
// Не рекомендуется:
this.items[2] = { id: 5, name: 'Груша' } 

// Рекомендуется:
this.$set(this.items, 2, { id: 5, name: 'Груша' })
```

$set гарантирует реактивное обновление.

В Vue 3 вместо этого можно писать так (это работает корректно с реактивностью):
this.items[2] = { id: 5, name: 'Груша' }

### Удаление элементов через length

Если вы, например, уменьшаете размер массива:

```js
this.items.length = 2
```

Это не всегда корректно обновляет DOM, особенно в Vue 2. Используйте методы splice, pop, shift для большей надёжности.

### Следите за уникальностью ключей

Если key не уникален или меняется динамически, Vue может неверно отрисовать список (например, не тот элемент будет удалён или обновлён).

## Применение вычисляемых свойств для обработки массивов

Вычисляемые свойства — мощный инструмент Vue, который часто применяют к работе с массивами: фильтрация, сортировка, подсчёты и агрегаты.

### Пример фильтрации в computed:

```js
computed: {
  толькоЯблоки() {
    // Оставляем только элементы с name равным 'Яблоко'
    return this.items.filter(item => item.name === 'Яблоко')
  }
}
```

В шаблоне:

```html
<ul>
  <li v-for="item in толькоЯблоки" :key="item.id">
    {{ item.name }}
  </li>
</ul>
```

Вычисляемое свойство `толькоЯблоки` будет автоматически пересчитываться при изменении массива `items`.

### Пример сортировки:

```js
computed: {
  отсортированныеФрукты() {
    // Сортируем фрукты по названию
    return [...this.items].sort((a, b) => a.name.localeCompare(b.name))
  }
}
```
 
Используем spread чтобы не мутировать оригинальный массив

## Массивы в Props и событиях — передача данных между компонентами

Vue предполагает часто работу с массивами не только внутри компонента, но и при обмене данными между ними.

### Передача массива как props

```js
// Родительский компонент
<fruit-list :items="myFruits"></fruit-list>
```
```js
// Дочерний компонент
props: {
  items: {
    type: Array,
    required: true
  }
}
```

Вы получаете массив, который можно безопасно обработать, выводить или мутировать (если договорились изменять именно здесь).

### Изменения массива через события

Лучше не мутировать props напрямую. Для этого организовывают поднятие событий в родительский компонент.

```js
// В дочернем компоненте
methods: {
  deleteItem(index) {
    this.$emit('delete', index)
  }
}
```

```html
<!-- Родитель слушает -->
<fruit-list :items="myFruits" @delete="onDelete"></fruit-list>
```

```js
methods: {
  onDelete(index) {
    this.myFruits.splice(index, 1) // Удаляем элемент у себя
  }
}
```

## Взаимодействие с массивами через формы

Очень часто используются формы, где пользователь добавляет или редактирует элементы массива.

### Пример динамического списка и добавления элементов

```html
<input v-model="newFruitName">
<button @click="addFruit">Добавить фрукт</button>
<ul>
  <li v-for="item in items" :key="item.id">
    {{ item.name }}
  </li>
</ul>
```

```js
data() {
  return {
    items: [],
    newFruitName: '',
    nextId: 1
  }
},
methods: {
  addFruit() {
    if (!this.newFruitName.trim()) return // Не добавляем пустое значение
    this.items.push({ id: this.nextId++, name: this.newFruitName })
    this.newFruitName = '' // Очищаем поле
  }
}
```

Это типовой сценарий добавления элементов в массив на основе пользовательского ввода.

## Масштабирование: массивы с вложенностью и работа с многоуровневыми структурами

Иногда ваши данные сложнее простого списка: например, товары с категориями, сообщения с вложенными комментариями.

### Рекурсивный вывод массивов

При обработке многоуровневых списков используют рекурсивные компоненты:

```js
// items: [{ id: 1, name: 'Категория', children: [...] }, ...]
```

```html
<template>
  <ul>
    <li v-for="item in items" :key="item.id">
      {{ item.name }}
      <category-list v-if="item.children" :items="item.children"></category-list>
    </li>
  </ul>
</template>
```

Здесь компонент CategoryList может вызывать сам себя для отображения вложенных данных

## Эффективность: оптимизация больших списков

Vue отлично работает с относительно небольшими списками. Для больших коллекций (> 500–1000 элементов) рекомендуется использовать виртуализацию через сторонние библиотеки (например, vue-virtual-scroller).

## Заключение

Работа с массивами во Vue — базовый, но очень широкий пласт практики современного фронтенда. Вы научились, как выводить массивы через v-for, добавлять и удалять элементы с реактивностью, обрабатывать данные через методы массивов, использовать вычисляемые свойства для фильтрации и сортировки, передавать массивы между компонентами и работать с более сложными структурами. На старте достаточно уделить внимание базовой реактивности и особенностям `v-for`, по мере роста приложения не забудьте об оптимизации и управлении сложными структурами данных.

Чтобы создавать полноценные приложения, необходимо понимать, как устроена маршрутизация, как управлять состоянием приложения и как взаимодействовать с сервером. Все эти аспекты подробно рассматриваются на нашем курсе [Vue.js 3, Vue Router и Pinia](https://purpleschool.ru/course/vuejs?utm_source=knowledgebase&utm_medium=article&utm_campaign=ispolzovanie-massivov-i-metodov-ih-obrabotki-v-vue). В первых 3 модулях уже доступно бесплатное содержание — начните погружаться в мир Vue прямо сегодня.

## Частозадаваемые технические вопросы по теме

**Вопрос 1:** Как правильно отслеживать изменения в массиве объектов, если изменился объект внутри массива, а не сам массив?

**Ответ:**  
Vue не всегда "видит" прямое изменение свойств объекта внутри массива (особенно если вы используете старый синтаксис). Решение — обновлять объект с помощью Vue.set (в Vue 2) или присваивать полностью новый объект. Например:
```js
// Для Vue 2:
this.$set(this.items, index, { ...this.items[index], name: 'Новое имя' })
// Для Vue 3:
this.items[index] = { ...this.items[index], name: 'Новое имя' }
```
Это гарантирует реактивное обновление.

**Вопрос 2:** Почему нельзя напрямую мутировать массив, переданный как props, в дочернем компоненте?

**Ответ:**  
Props во Vue должны оставаться неизменными внутри дочернего компонента — это важная часть архитектуры. Мутируйте массив не напрямую, а через поднятие событий и изменение в родителе.

**Вопрос 3:** Как эффективно отслеживать изменения фильтрованного или отсортированного списка?

**Ответ:**  
Используйте computed для создания фильтрованной/отсортированной версии массива. Изменения исходного массива автоматически отразятся на вычисленном свойстве благодаря реактивности Vue.

**Вопрос 4:** Как сделать reset/очистку массива?

**Ответ:**  
Для полной очистки массива используйте `this.items = []` или `this.items.splice(0, this.items.length)`. Первый вариант подойдет, если массив не был передан через props.

**Вопрос 5:** Как избежать ошибок при использовании индекса в качестве key в v-for?

**Ответ:**  
Используйте уникальные идентификаторы (например, id), а не index, чтобы избежать ошибок при изменении порядка элементов или их удалении. Index подходит только для статичных списков, которые никогда не будут изменяться.
