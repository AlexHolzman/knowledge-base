---
metaTitle: Работа с lifecycle-хуком onMounted во Vue
metaDescription: Узнайте как применять onMounted во Vue - организуйте выполнение кода при инициализации компонента, интегрируйте сторонние библиотеки и взаимодействуйте с DOM
author: Олег Марков
title: Работа с lifecycle-хуком onMounted во Vue
preview: Погрузитесь в применения lifecycle-хука onMounted во Vue - разберитесь когда и зачем его вызывать, как код удобно выполняется при появлении компонента на странице
---

## Введение

Во Vue существует целая система жизненного цикла компонента, каждая стадия которого предоставляет свои возможности для выполнения вашего кода. Одной из ключевых точек этого жизненного цикла является момент, когда компонент уже отрисован на странице, и вы готовы обратиться к DOM, выполнить запросы или инициировать работу сторонних библиотек. Именно здесь на помощь приходит жизненный цикл-хук `onMounted`.  
Сегодня мы вместе разберем что такое onMounted, зачем он нужен, какие задачи решает, как правильно его использовать во Vue 3 и чем он отличается от похожих решений в других версиях Vue. По пути рассмотрим много практических примеров.

## Хук onMounted — теория и назначение

### Что такое lifecycle-хук onMounted

В экосистеме Vue, `onMounted` — это специальный хук жизненного цикла, который позволяет выполнять ваш код после того, как экземпляр компонента связан с DOM и полностью отрисован. Это значит, что любые манипуляции с DOM-элементами компонента, настройка событий, интеграция внешних библиотек, обращение к ref и многое другое удобно выполнять именно в этом хукe.

В старой опции API (`Vue 2.x`) для этого использовался метод `mounted`. В Composition API (тот, что с функциями реактивности и setup) его эквивалентом является функция `onMounted`.

Lifecycle-хук `onMounted` во Vue позволяет выполнять код после монтирования компонента в DOM. Этот хук часто используется для инициализации сторонних библиотек, взаимодействия с DOM и выполнения других операций, требующих доступа к DOM-элементам. Чтобы узнать, как применять `onMounted` во Vue, организовать выполнение кода при инициализации компонента, интегрировать сторонние библиотеки и взаимодействовать с DOM, рекомендуем наш курс [Vue.js 3, Vue Router и Pinia](https://purpleschool.ru/course/vuejs?utm_source=knowledgebase&utm_medium=article&utm_campaign=rabota-s-lifecycle-hukom-onMounted-vo-vue). На курсе 173 уроков и 21 упражнение, AI-тренажеры для безлимитной практики с кодом и задачами 24/7, решение задач с живым ревью наставника, еженедельные встречи с менторами.

### Когда вызывается onMounted

- После того как компонент был **полностью смонтирован** (отрисован) в DOM
- Все реактивные значения и computed уже работают
- Все дочерние компоненты прошли свои стадии монтирования

Обратите внимание: хук `onMounted` не сработает, пока компонент не появился на странице. Если компонент скрыт условием v-if — хук вызовется только при его показе.

## Использование onMounted в Composition API

### Базовый пример

Давайте разберем основной синтаксис использования onMounted во Vue 3 с помощью Composition API.

```js
<script setup>
// Импортируем функцию onMounted
import { onMounted, ref } from 'vue'

const message = ref('Привет, Vue 3!')

onMounted(() => {
  // Этот код выполнится после монтирования компонента
  console.log('Компонент успешно смонтирован!')
  message.value = 'Компонент уже на странице!'
})
</script>

<template>
  <div>{{ message }}</div>
</template>
```

Что здесь происходит?  
После монтирования компонент выводит сообщение в консоль и сразу обновляет своё реактивное значение message.  
`onMounted` принимает функцию-колбэк, которая и выполняется после полной отрисовки.

### Получение доступа к DOM-элементам через ref

Очень часто onMounted используют, чтобы работать с DOM узлами через ref.  
Вот пример:

```js
<script setup>
import { ref, onMounted } from 'vue'

// Объявляем ref для DOM-элемента
const inputEl = ref(null)

onMounted(() => {
  // Теперь можно фокусировать input, потому что он гарантированно уже есть в DOM
  inputEl.value.focus()
})
</script>

<template>
  <input ref="inputEl" type="text" placeholder="Курсор появится сразу здесь" />
</template>
```

Смотрите: только после срабатывания onMounted свойство `inputEl.value` содержит DOM-элемент, а не null. Вы можете свободно его использовать.

### Загрузка данных с сервера

Один из частых кейсов — подгрузка данных с сервера, когда компонент загружается. Обычно работу с API тоже размещают в onMounted.

```js
<script setup>
import { ref, onMounted } from 'vue'

const users = ref([])
const loading = ref(false)
const error = ref(null)

onMounted(async () => {
  loading.value = true
  try {
    const response = await fetch('https://jsonplaceholder.typicode.com/users')
    users.value = await response.json()
  } catch (e) {
    error.value = 'Ошибка загрузки данных'
  } finally {
    loading.value = false
  }
})
</script>

<template>
  <div v-if="loading">Загрузка...</div>
  <div v-else-if="error">{{ error }}</div>
  <ul v-else>
    <li v-for="user in users" :key="user.id">
      {{ user.name }}
    </li>
  </ul>
</template>
```

Обратите внимание, что здесь используется асинхронная функция внутри onMounted. Это разрешено и довольно удобно.

### Интеграция сторонних библиотек

Давайте рассмотрим ситуацию, когда вам необходимо подключить плагин или библиотеку, работающую с DOM. Например, инициализировать datepicker или библиотеку визуализации данных.

```js
<script setup>
import { ref, onMounted } from 'vue'
import Pikaday from 'pikaday'

const pickerEl = ref(null)

onMounted(() => {
  // Инициализация Pikaday после появления элемента в DOM
  new Pikaday({
    field: pickerEl.value
  })
})
</script>

<template>
  <input ref="pickerEl" placeholder="Выберите дату" />
</template>
```

Важно! Все сторонние библиотеки, связанные с реальным DOM, должны инициализироваться именно в onMounted.

### Несколько onMounted в одном компоненте

Во Vue 3 вы спокойно можете вызывать `onMounted` несколько раз в одном компоненте, например:

```js
<script setup>
import { onMounted } from 'vue'

onMounted(() => {
  console.log('Первое действие при монтировании')
})

onMounted(() => {
  console.log('Второе действие при монтировании')
})
</script>
```

Все функции будут вызваны по очереди.

### Совместное использование onMounted и других хуков (onUpdated, onUnmounted)

Иногда возникает ситуация: вы инициализируете стороннюю библиотеку в onMounted и хотите корректно её удалить при размонтировании компонента.  
Для этого используйте пару onMounted и onUnmounted:

```js
<script setup>
import { ref, onMounted, onUnmounted } from 'vue'

const intervalId = ref(0)

onMounted(() => {
  // Запускаем таймер при монтировании
  intervalId.value = setInterval(() => {
    console.log('Таймер тикает')
  }, 1000)
})

onUnmounted(() => {
  // Очищаем таймер при размонтировании
  clearInterval(intervalId.value)
})
</script>
```
Такой подход предотвращает утечки памяти и ошибки при повторном монтировании компонента.

## onMounted: Различия во Vue 2 и Vue 3

### Сравнение Options API (Vue 2) и Composition API (Vue 3)

В классическом Options API (Vue 2) вы использовали вот такой синтаксис:
```js
export default {
  data() {
    return { count: 0 }
  },
  mounted() {
    console.log('Компонент смонтирован')
  }
}
```

С приходом Composition API (Vue 3) всё выглядит чуть иначе:
```js
import { onMounted } from 'vue'

export default {
  setup() {
    onMounted(() => {
      console.log('Компонент смонтирован в setup')
    })
  }
}
```

Главное отличие: в Vue 3 с Composition API хук может использоваться гораздо более гибко — его можно вызывать сколько угодно раз, группировать с другими реактивными функциями, выносить в кастомные хуки (use-функции).

### Передача хуков между компонентами

Вот как можно вынести логику монтирования в отдельную функцию и переиспользовать:

```js
// useLogger.js
import { onMounted } from 'vue'

export function useLogger(msg) {
  onMounted(() => {
    console.log(msg)
  })
}

// MyComponent.vue
<script setup>
import { useLogger } from './useLogger'

useLogger('Компонент загружен!')
</script>
```

Это одно из ключевых преимуществ Composition API.

## onMounted в сложных компонентах

### Когда монтируются родительские и дочерние компоненты

Может возникнуть вопрос: что если у компонента есть дочерние компоненты, чей onMounted срабатывает первым?  
Во Vue хук onMounted вызывается для **дочерних компонентов раньше**, чем для родителя.  
Смотрите порядок на примере:

```js
// Parent.vue
<script setup>
import { onMounted } from 'vue'
onMounted(() => {
  console.log('Родитель смонтирован')
})
</script>
<template>
  <Child />
</template>

// Child.vue
<script setup>
import { onMounted } from 'vue'
onMounted(() => {
  console.log('Дочерний компонент смонтирован')
})
</script>
```

В консоли вы увидите:
```
Дочерний компонент смонтирован
Родитель смонтирован
```

Это позволяет гарантировать, что когда родитель "очнулся", дочерние уже на месте и доступны для взаимодействия.

### onMounted и v-if/v-for

onMounted **не срабатывает**, пока компонент не был реально добавлен в DOM.  
Если элемент спрятан через v-if или добавляется через v-for — хук вызовется только когда соответствующее условие выполнится.

```js
<Child v-if="showChild" />
```

Если `showChild` false — Child не монтируется и onMounted НЕ срабатывает.

### Динамическая загрузка компонентов

Если используете dynamic imports или динамически управляете списком компонентов (например, tabs), то onMounted вызовется **при первом появлении компонента** на странице, а при повторном использовании сам по себе не вызывает этот хук снова (если компонент не был уничтожен).

## Особенности использования onMounted

### Можно ли использовать асинхронные функции внутри onMounted

Да, внутри onMounted можно использовать async-функции, однако сам onMounted не ждет завершения асинхронной операции:

```js
onMounted(async () => {
  await fetchData()
})
```
Vue не ждет, когда fetchData завершится — основной поток инициализации компонентов продолжается.

### Не используйте onMounted вне setup

onMounted работает **только** внутри setup (или внутри composable-функций, вызываемых из setup). Снаружи setup onMounted работать не будет.

### Доступ к this внутри onMounted

В Composition API вы НЕ работаете с `this` — используйте объявленные в scope переменные и ref.

## Краткая памятка по onMounted

#### Когда использовать:

- Нужно инициализировать данные только при первом появлении компонента
- Требуется настроить сторонний плагин, работу со сторонним DOM-API
- Необходимо взаимодействие с ref-элементами
- Нужно выполнить асинхронную загрузку данных после отрисовки

#### Когда не использовать:

- Когда задача не связана с DOM, загрузкой данных или инициализацией сервисов под конкретный компонент при его появлении
- Для вычислений, которые могут быть выполнены до отрисовки

## Заключение

onMounted — один из основных "точек входа" в жизненном цикле компонента во Vue. Это универсальный инструмент для работы с DOM, запуска загрузки данных и установки вспомогательных библиотек строго в момент появления компонента на странице. Используя его грамотно, вы сделаете свои компоненты предсказуемыми, надежными и чистыми, уменьшите вероятность ошибок, связанных с несвоевременным доступом к DOM или зависимостями.  
Теперь у вас под рукой богатый арсенал практических примеров и вы владеете тонкостями применения onMounted в рамках современного Composition API.

Использование lifecycle-хуков - ключевой аспект в разработке Vue приложений. Узнайте, как правильно их использовать, чтобы создавать крутые приложения на курсе [Vue.js 3, Vue Router и Pinia](https://purpleschool.ru/course/vuejs?utm_source=knowledgebase&utm_medium=article&utm_campaign=rabota-s-lifecycle-hukom-onMounted-vo-vue). В первых 3 модулях уже доступно бесплатное содержание — начните погружаться в мир Vue прямо сейчас.

## Частозадаваемые технические вопросы по onMounted

### Как правильно сбросить или "очистить" действия, начатые в onMounted, чтобы избежать утечек памяти?

Часто нужно завершить обработчики событий, очищать интервалы или уничтожать плагины. Для этого используйте связку onMounted и onUnmounted:

```js
let intervalId

onMounted(() => {
  intervalId = setInterval(() => { /* ... */ }, 1000)
})

onUnmounted(() => {
  clearInterval(intervalId)
})
```

### Как протестировать onMounted в unit-тестах?

Воспользуйтесь @vue/test-utils и методами mount, shallowMount. После монтирования компонента onMounted запустится автоматически. Можно проверять side-effect'ы или мокать асинхронные вызовы.

```js
const wrapper = mount(MyComponent)
// onMounted выполнится, проверяйте эффекты напрямую
```

### Почему onMounted не срабатывает при условном рендеринге компонента (v-if)?

onMounted вызовется **только** при фактическом появлении компонента в DOM. Если v-if изначально false, компонент не инициализируется. Переведите v-if в true, и хук сразу же сработает.

### Нужно ли использовать watch внутри onMounted, если требуется отследить изменение props?

Нет, onMounted активируется только один раз, при первом появлении компонента. Для отслеживания изменений используйте watch или watchEffect.

### Можно ли использовать onMounted внутри кастомного composable-файла (use-логики)?

Да, это распространённый паттерн. Просто вызовите onMounted внутри вашей функции, а функцию — внутри setup. Vue сам организует правильное выполнение хуков в нужном контексте.
